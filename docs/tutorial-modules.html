<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Chopin Tutorial - Modular Architecture: MVSR pattern, ChopinModule trait, and Django-style startapp.">
    <title>Tutorial: Modular Architecture - Chopin Framework</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/tutorial.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&family=Caveat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
</head>
<body>
    <!-- Navigation -->
    <nav class="nav">
        <div class="container">
            <div class="nav-content">
                <div class="nav-logo">
                    <a href="index.html" style="display:flex;align-items:center;gap:0.75rem;text-decoration:none;color:inherit;">
                        <i data-lucide="music" class="logo-icon"></i>
                        <span class="logo-text">Chopin</span>
                    </a>
                </div>
                <div class="nav-links">
                    <a href="index.html#features">Features</a>
                    <a href="index.html#benchmarks">Benchmarks</a>
                    <a href="tutorial-index.html">Tutorial</a>
                    <a href="https://docs.rs/chopin">API Docs</a>
                    <a href="https://github.com/kowito/chopin" class="btn-primary">GitHub</a>
                </div>
            </div>
        </div>
    </nav>

    <div class="tutorial-layout">
        <!-- Sidebar TOC -->
        <aside class="tutorial-sidebar">
            <div class="toc">
                <h3 class="toc-title">Modules</h3>
                <ol class="toc-list">
                    <li><a href="#architecture" class="toc-link">Architecture Overview</a></li>
                    <li><a href="#startapp" class="toc-link">Creating Modules</a></li>
                    <li><a href="#mvsr" class="toc-link">MVSR Pattern Overview</a></li>
                    <li><a href="#models" class="toc-link">Models (M)</a></li>
                    <li><a href="#dtos" class="toc-link">DTOs (D)</a></li>
                    <li><a href="#services" class="toc-link">Services (S)</a></li>
                    <li><a href="#handlers" class="toc-link">Handlers (V)</a></li>
                    <li><a href="#routes" class="toc-link">Routes (R)</a></li>
                    <li><a href="#request-flow" class="toc-link">Request Flow</a></li>
                    <li><a href="#testing" class="toc-link">Testing Strategies</a></li>
                    <li><a href="#chopin-module" class="toc-link">ChopinModule Trait</a></li>
                    <li><a href="#mounting" class="toc-link">Mounting & Composition</a></li>
                    <li><a href="#best-practices" class="toc-link">Best Practices</a></li>
                </ol>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="tutorial-content">

            <!-- Hero -->
            <div class="tutorial-hero">
                <h1>Modular Architecture</h1>
                <p>Chopin uses a <strong>hub-and-spoke</strong> module system inspired by Django. Each feature is a self-contained module with its own routes, handlers, services, models, and DTOs — composed together in <code>main.rs</code>.</p>
                <div class="page-indicator">Page 6 of 7</div>
            </div>

            <!-- 1. Architecture Overview -->
            <section id="architecture" class="tutorial-section">
                <div class="section-number">20</div>
                <h2>Architecture Overview</h2>
                <p>Chopin follows a <strong>hub-and-spoke</strong> architecture. The <code>main.rs</code> file is the "hub" (or "Composer") that mounts independent feature modules (the "spokes"). Each module implements the <code>ChopinModule</code> trait.</p>

<pre><code><span class="comment"># Project layout</span>
my-api/
├── src/
│   ├── main.rs              <span class="comment"># The "Composer" — mounts all modules</span>
│   ├── apps/
│   │   ├── mod.rs           <span class="comment"># Module registry</span>
│   │   ├── blog/            <span class="comment"># Feature module (MVSR)</span>
│   │   │   ├── mod.rs       <span class="comment"># ChopinModule implementation</span>
│   │   │   ├── routes.rs    <span class="comment"># Route definitions</span>
│   │   │   ├── handlers.rs  <span class="comment"># HTTP handlers (thin adapters)</span>
│   │   │   ├── services.rs  <span class="comment"># Pure business logic</span>
│   │   │   ├── models.rs    <span class="comment"># SeaORM entities</span>
│   │   │   └── dto.rs       <span class="comment"># Request/response types</span>
│   │   └── billing/         <span class="comment"># Another feature module</span>
│   │       └── ...
│   └── shared/              <span class="comment"># Cross-cutting types &amp; utilities</span>
│       └── mod.rs
├── migrations/              <span class="comment"># App-level database migrations</span>
├── tests/                   <span class="comment"># Integration tests</span>
├── .env
└── Cargo.toml</code></pre>

                <div class="callout">
                    <i data-lucide="info" class="inline-icon"></i>
                    <div>
                        <strong>Key principle:</strong> Modules never depend on each other — only on <code>chopin-core</code> and <code>src/shared/</code>. This makes each module independently testable, replaceable, and reusable.
                    </div>
                </div>
            </section>

            <!-- 2. Creating Modules -->
            <section id="startapp" class="tutorial-section">
                <div class="section-number">21</div>
                <h2>Creating Modules</h2>
                <p>Use the <code>chopin startapp</code> command (inspired by Django's <code>manage.py startapp</code>) to scaffold a complete feature module:</p>

<pre><code><span class="comment"># Create a new module — generates all MVSR files</span>
chopin startapp blog

<span class="comment"># Equivalent alternative:</span>
chopin generate module blog</code></pre>

                <p>This creates the following structure:</p>

<pre><code><span class="comment"># src/apps/blog/</span>
<span class="comment">#   mod.rs        — ChopinModule trait implementation</span>
<span class="comment">#   routes.rs     — Route definitions (nested under /api/blogs)</span>
<span class="comment">#   handlers.rs   — HTTP handler functions</span>
<span class="comment">#   services.rs   — Pure business logic (no HTTP types)</span>
<span class="comment">#   models.rs     — SeaORM entity definitions</span>
<span class="comment">#   dto.rs        — Request/response DTOs with ToSchema</span></code></pre>

                <p>And automatically:</p>
                <ul>
                    <li>Adds <code>pub mod blog;</code> to <code>src/apps/mod.rs</code></li>
                    <li>Adds <code>.mount_module(apps::blog::BlogModule::new())</code> to <code>src/main.rs</code></li>
                    <li>Creates <code>tests/blog_tests.rs</code> with starter integration tests</li>
                </ul>

                <h3>Generate a model inside a module</h3>
<pre><code><span class="comment"># Place the model entity inside an existing module</span>
chopin generate model Post title:string body:text --module blog

<span class="comment"># This updates src/apps/blog/models.rs with a SeaORM entity</span>
<span class="comment"># and creates migrations/m2025XXXX_create_posts_table.rs</span></code></pre>
            </section>

            <!-- 3. MVSR Pattern -->
            <!-- 3. MVSR Pattern Overview -->
            <section id="mvsr" class="tutorial-section">
                <div class="section-number">22</div>
                <h2>MVSR Pattern Overview</h2>
                <p>Every module follows the <strong>MVSR pattern</strong>: Model – View/Handler – Service – Router. This separates concerns clearly and makes each layer independently testable.</p>

                <table>
                    <thead>
                        <tr><th>Layer</th><th>File</th><th>Responsibility</th></tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Model</strong></td>
                            <td><code>models.rs</code></td>
                            <td>SeaORM entities &amp; database schema</td>
                        </tr>
                        <tr>
                            <td><strong>DTO</strong></td>
                            <td><code>dto.rs</code></td>
                            <td>Request/response types with <code>Serialize</code>, <code>Deserialize</code>, <code>ToSchema</code></td>
                        </tr>
                        <tr>
                            <td><strong>Service</strong></td>
                            <td><code>services.rs</code></td>
                            <td>Pure business logic. No HTTP types. Receives <code>DatabaseConnection</code>, returns domain types.</td>
                        </tr>
                        <tr>
                            <td><strong>View/Handler</strong></td>
                            <td><code>handlers.rs</code></td>
                            <td>Thin HTTP adapters: extract request → call service → return response</td>
                        </tr>
                        <tr>
                            <td><strong>Router</strong></td>
                            <td><code>routes.rs</code></td>
                            <td>Maps HTTP methods + paths to handler functions</td>
                        </tr>
                    </tbody>
                </table>

                <div class="callout">
                    <i data-lucide="info" class="inline-icon"></i>
                    <div>
                        <strong>Why this separation?</strong> Each layer has a single responsibility. Models handle data persistence, DTOs define contracts, Services contain business logic, Handlers adapt HTTP to domain logic, and Routes wire everything together. This makes each layer independently testable.
                    </div>
                </div>
            </section>

            <!-- 4. Models (M) -->
            <section id="models" class="tutorial-section">
                <div class="section-number">23</div>
                <h2>Models (M) — Database Layer</h2>
                <p>Models are <strong>SeaORM entities</strong> that define your database schema. They represent tables and handle persistence.</p>

                <h3>Defining a Model</h3>
<pre><code><span class="comment">// src/apps/blog/models.rs</span>
<span class="kw">use</span> chrono::Utc;
<span class="kw">use</span> sea_orm::prelude::*;
<span class="kw">use</span> serde::{Deserialize, Serialize};

<span class="attr">#[derive(Clone, Debug, DeriveEntityModel, Serialize, Deserialize)]</span>
<span class="attr">#[sea_orm(table_name = "blog")]</span>
<span class="kw">pub struct</span> Model {
    <span class="attr">#[sea_orm(primary_key)]</span>
    <span class="kw">pub</span> id: <span class="type">i32</span>,
    <span class="kw">pub</span> title: <span class="type">String</span>,
    <span class="kw">pub</span> body: <span class="type">String</span>,
    <span class="kw">pub</span> author_id: <span class="type">i32</span>,
    <span class="kw">pub</span> created_at: DateTime,
    <span class="kw">pub</span> updated_at: DateTime,
}

<span class="attr">#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]</span>
<span class="kw">pub enum</span> Relation {}

<span class="kw">impl</span> ActiveModelBehavior <span class="kw">for</span> ActiveModel {}</code></pre>

                <div class="callout">
                    <i data-lucide="lightbulb" class="inline-icon"></i>
                    <div>
                        <strong>Key Points:</strong> Models are pure data structures. They never contain business logic. Use <code>DeriveEntityModel</code> for SeaORM integration. Add <code>Serialize</code>/<code>Deserialize</code> if you need JSON conversion.
                    </div>
                </div>
            </section>

            <!-- 5. DTOs (D) -->
            <section id="dtos" class="tutorial-section">
                <div class="section-number">24</div>
                <h2>DTOs (D) — Data Transfer Objects</h2>
                <p>DTOs define request/response contracts with validation and OpenAPI documentation. They're separate from models to decouple API contracts from database schema.</p>

                <h3>Request DTOs</h3>
<pre><code><span class="comment">// src/apps/blog/dto.rs</span>
<span class="kw">use</span> serde::{Deserialize, Serialize};
<span class="kw">use</span> utoipa::ToSchema;

<span class="attr">#[derive(Debug, Serialize, Deserialize, ToSchema)]</span>
<span class="kw">pub struct</span> CreateBlogRequest {
    <span class="attr">#[schema(example = "My First Post")]</span>
    <span class="kw">pub</span> title: String,

    <span class="attr">#[schema(example = "This is the content...")]</span>
    <span class="kw">pub</span> body: String,
}

<span class="attr">#[derive(Debug, Serialize, Deserialize, ToSchema)]</span>
<span class="kw">pub struct</span> BlogResponse {
    <span class="kw">pub</span> id: <span class="type">i32</span>,
    <span class="kw">pub</span> title: String,
    <span class="kw">pub</span> body: String,
    <span class="kw">pub</span> author_id: <span class="type">i32</span>,
}

<span class="comment">// Conversions from Model to DTO</span>
<span class="kw">impl</span> From&lt;super::models::Model&gt; <span class="kw">for</span> BlogResponse {
    <span class="kw">fn</span> from(m: super::models::Model) -> <span class="type">Self</span> {
        <span class="type">Self</span> {
            id: m.id,
            title: m.title,
            body: m.body,
            author_id: m.author_id,
        }
    }
}</code></pre>

                <div class="callout">
                    <i data-lucide="shield" class="inline-icon"></i>
                    <div>
                        <strong>Why DTOs?</strong> DTOs let you expose only the fields you want in your API while keeping internal database fields private. Change your database schema without breaking API contracts.
                    </div>
                </div>
            </section>

            <!-- 6. Services (S) -->
            <section id="services" class="tutorial-section">
                <div class="section-number">25</div>
                <h2>Services (S) — Business Logic</h2>
                <p>Services contain pure business logic. They're <strong>HTTP-free</strong> — no request/response types, just database connections and domain objects. This makes them 100% unit-testable.</p>

                <h3>Service Layer Example</h3>
<pre><code><span class="comment">// src/apps/blog/services.rs</span>
<span class="kw">use</span> chopin_core::error::ChopinError;
<span class="kw">use</span> sea_orm::*;
<span class="kw">use</span> super::dto::*;
<span class="kw">use</span> super::models::{self, Entity <span class="kw">as</span> Blog};

<span class="kw">pub async fn</span> <span class="fn">list_all</span>(db: &DatabaseConnection) -> <span class="type">Result</span>&lt;Vec&lt;BlogResponse&gt;, ChopinError&gt; {
    <span class="kw">let</span> items = Blog::find()
        .order_by_desc(models::Column::CreatedAt)
        .all(db).<span class="kw">await</span>
        .map_err(|e| ChopinError::Database(e.to_string()))?;
    <span class="type">Ok</span>(items.into_iter().map(BlogResponse::from).collect())
}

<span class="kw">pub async fn</span> <span class="fn">create_one</span>(
    db: &DatabaseConnection,
    payload: CreateBlogRequest,
) -> <span class="type">Result</span>&lt;BlogResponse, ChopinError&gt; {
    <span class="kw">let</span> new = models::ActiveModel {
        title: Set(payload.title),
        body: Set(payload.body),
        ..Default::default()
    };
    <span class="kw">let</span> result = new.insert(db).<span class="kw">await</span>
        .map_err(|e| ChopinError::Database(e.to_string()))?;
    <span class="type">Ok</span>(BlogResponse::from(result))
}

<span class="kw">pub async fn</span> <span class="fn">find_by_id</span>(
    db: &DatabaseConnection,
    id: <span class="type">i32</span>,
) -> <span class="type">Result</span>&lt;BlogResponse, ChopinError&gt; {
    Blog::find_by_id(id).one(db).<span class="kw">await</span>
        .map_err(|e| ChopinError::Database(e.to_string()))?
        .map(BlogResponse::from)
        .ok_or_else(|| ChopinError::NotFound(<span class="kw">format!</span>(<span class="str">"Blog {} not found"</span>, id)))
}</code></pre>

                <h3>Validation in Services</h3>
<pre><code><span class="kw">pub async fn</span> <span class="fn">create_validated</span>(
    db: &DatabaseConnection,
    payload: CreateBlogRequest,
) -> <span class="type">Result</span>&lt;BlogResponse, ChopinError&gt; {
    <span class="comment">// Validate</span>
    <span class="kw">if</span> payload.title.is_empty() {
        <span class="kw">return</span> Err(ChopinError::Validation(
            <span class="str">"Title cannot be empty"</span>.to_string()
        ));
    }
    <span class="comment">// Then create...</span>
    create_one(db, payload).<span class="kw">await</span>
}</code></pre>

                <h3>Database Transactions</h3>
<pre><code><span class="kw">pub async fn</span> <span class="fn">create_with_tags</span>(
    db: &DatabaseConnection,
    blog_req: CreateBlogRequest,
    tag_ids: Vec&lt;<span class="type">i32</span>&gt;,
) -> <span class="type">Result</span>&lt;BlogResponse, ChopinError&gt; {
    <span class="kw">let</span> txn = db.begin().<span class="kw">await</span>
        .map_err(|e| ChopinError::Database(e.to_string()))?;

    <span class="comment">// Create blog</span>
    <span class="kw">let</span> blog = models::ActiveModel {
        title: Set(blog_req.title),
        body: Set(blog_req.body),
        ..Default::default()
    }.insert(&txn).<span class="kw">await</span>
        .map_err(|e| ChopinError::Database(e.to_string()))?;

    <span class="comment">// Associate tags...</span>

    txn.commit().<span class="kw">await</span>
        .map_err(|e| ChopinError::Database(e.to_string()))?;

    <span class="type">Ok</span>(BlogResponse::from(blog))
}</code></pre>

                <div class="callout">
                    <i data-lucide="check-circle" class="inline-icon"></i>
                    <div>
                        <strong>Key Principle:</strong> Services never import HTTP types. They're pure Rust functions that take domain inputs and return domain outputs. This keeps them testable and reusable.
                    </div>
                </div>
            </section>

            <!-- 7. Handlers (V) -->
            <section id="handlers" class="tutorial-section">
                <div class="section-number">26</div>
                <h2>Handlers (V) — HTTP Adapters</h2>
                <p>Handlers are thin HTTP adapters. They extract data from requests, call services, and format responses. Keep them minimal — all business logic belongs in services.</p>

                <h3>Basic Handlers</h3>
<pre><code><span class="comment">// src/apps/blog/handlers.rs</span>
<span class="kw">use</span> axum::{extract::*, http::StatusCode, response::IntoResponse};
<span class="kw">use</span> chopin_core::extractors::JsonBody;
<span class="kw">use</span> chopin_core::controllers::AppState;
<span class="kw">use</span> super::{dto::*, services};

<span class="comment">/// GET /api/blogs — list all blog posts</span>
<span class="kw">pub async fn</span> <span class="fn">list_blogs</span>(
    State(state): State&lt;AppState&gt;,
) -> <span class="type">Result</span>&lt;Json&lt;Vec&lt;BlogResponse&gt;&gt;, StatusCode&gt; {
    services::list_all(&state.db).<span class="kw">await</span>
        .map(Json)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)
}

<span class="comment">/// POST /api/blogs — create a new blog post</span>
<span class="kw">pub async fn</span> <span class="fn">create_blog</span>(
    State(state): State&lt;AppState&gt;,
    JsonBody(payload): JsonBody&lt;CreateBlogRequest&gt;,
) -> <span class="type">Result</span>&lt;(StatusCode, Json&lt;BlogResponse&gt;), StatusCode&gt; {
    <span class="kw">let</span> blog = services::create_one(&state.db, payload).<span class="kw">await</span>
        .map_err(|_| StatusCode::BAD_REQUEST)?;
    <span class="type">Ok</span>((StatusCode::CREATED, Json(blog)))
}

<span class="comment">/// GET /api/blogs/:id — get a specific blog post</span>
<span class="kw">pub async fn</span> <span class="fn">get_blog</span>(
    State(state): State&lt;AppState&gt;,
    Path(id): Path&lt;<span class="type">i32</span>&gt;,
) -> <span class="type">Result</span>&lt;Json&lt;BlogResponse&gt;, StatusCode&gt; {
    services::find_by_id(&state.db, id).<span class="kw">await</span>
        .map(Json)
        .map_err(|_| StatusCode::NOT_FOUND)
}</code></pre>

                <h3>Auth-Protected Handlers</h3>
<pre><code><span class="kw">use</span> chopin_core::extractors::AuthUser;

<span class="kw">pub async fn</span> <span class="fn">create_as_user</span>(
    State(state): State&lt;AppState&gt;,
    user: AuthUser,  <span class="comment">// Extracted from JWT</span>
    JsonBody(payload): JsonBody&lt;CreateBlogRequest&gt;,
) -> <span class="type">Result</span>&lt;Json&lt;BlogResponse&gt;, StatusCode&gt; {
    services::create_one_for_user(&state.db, user.id, payload).<span class="kw">await</span>
        .map(Json)
        .map_err(|_| StatusCode::BAD_REQUEST)
}</code></pre>

                <div class="callout">
                    <i data-lucide="zap" class="inline-icon"></i>
                    <div>
                        <strong>Handler Rule:</strong> Handlers should be 3-5 lines max. Extract → Call Service → Return. No business logic here.
                    </div>
                </div>
            </section>

            <!-- 8. Routes (R) -->
            <section id="routes" class="tutorial-section">
                <div class="section-number">27</div>
                <h2>Routes (R) — URL Mapping</h2>
                <p>Routes map HTTP methods and paths to handler functions. They wire the entire request flow together.</p>

                <h3>Basic Route Definition</h3>
<pre><code><span class="comment">// src/apps/blog/routes.rs</span>
<span class="kw">use</span> axum::{routing::*, Router};
<span class="kw">use</span> chopin_core::controllers::AppState;
<span class="kw">use</span> super::handlers;

<span class="kw">pub fn</span> <span class="fn">routes</span>() -> Router&lt;AppState&gt; {
    Router::new()
        .route(
            <span class="str">"/api/blogs"</span>,
            <span class="fn">get</span>(handlers::list_blogs).<span class="fn">post</span>(handlers::create_blog)
        )
        .route(
            <span class="str">"/api/blogs/:id"</span>,
            <span class="fn">get</span>(handlers::get_blog)
                .<span class="fn">put</span>(handlers::update_blog)
                .<span class="fn">delete</span>(handlers::delete_blog)
        )
}</code></pre>

                <h3>HTTP Methods</h3>
<pre><code><span class="comment">// CRUD endpoints</span>
.route(<span class="str">"/items"</span>, <span class="fn">get</span>(list).<span class="fn">post</span>(create))
.route(<span class="str">"/items/:id"</span>, <span class="fn">get</span>(get_one).<span class="fn">put</span>(update).<span class="fn">patch</span>(partial_update).<span class="fn">delete</span>(remove))</code></pre>

                <h3>Path Parameters</h3>
<pre><code><span class="comment">// Single parameter</span>
.route(<span class="str">"/blogs/:id"</span>, <span class="fn">get</span>(get_blog))

<span class="comment">// Multiple parameters</span>
.route(<span class="str">"/users/:user_id/posts/:post_id"</span>, <span class="fn">get</span>(get_user_post))</code></pre>

                <h3>Nesting Routes</h3>
<pre><code><span class="kw">pub fn</span> <span class="fn">routes</span>() -> Router&lt;AppState&gt; {
    Router::new()
        .nest(
            <span class="str">"/api/blogs"</span>,
            Router::new()
                .route(<span class="str">""</span>, <span class="fn">get</span>(list).<span class="fn">post</span>(create))
                .route(<span class="str">":id"</span>, <span class="fn">get</span>(get_one).<span class="fn">put</span>(update).<span class="fn">delete</span>(remove))
                .route(<span class="str">":id/comments"</span>, <span class="fn">get</span>(list_comments))
        )
}</code></pre>

                <h3>Query Parameters</h3>
<pre><code><span class="kw">use</span> axum::extract::Query;
<span class="kw">use</span> serde::Deserialize;

<span class="attr">#[derive(Deserialize)]</span>
<span class="kw">struct</span> ListQuery {
    skip: Option&lt;<span class="type">i32</span>&gt;,
    take: Option&lt;<span class="type">i32</span>&gt;,
}

<span class="kw">pub async fn</span> <span class="fn">list_blogs</span>(Query(q): Query&lt;ListQuery&gt;) {
    <span class="comment">// Use q.skip and q.take...</span>
}</code></pre>

                <h3>Route Middleware</h3>
<pre><code><span class="kw">use</span> axum::middleware;

Router::new()
    <span class="comment">// Public routes</span>
    .route(<span class="str">"/login"</span>, <span class="fn">post</span>(login))
    
    <span class="comment">// Protected routes</span>
    .route(<span class="str">"/profile"</span>, <span class="fn">get</span>(profile))
    .layer(middleware::from_fn(require_auth))
    
    <span class="comment">// Admin routes</span>
    .route(<span class="str">"/admin/users"</span>, <span class="fn">get</span>(list_users))
    .layer(middleware::from_fn(require_admin))</code></pre>

                <h3>RESTful Conventions</h3>
<pre><code>GET    <span class="str">/api/posts</span>              <span class="comment">→ list_posts</span>
POST   <span class="str">/api/posts</span>              <span class="comment">→ create_post</span>
GET    <span class="str">/api/posts/:id</span>          <span class="comment">→ get_post</span>
PUT    <span class="str">/api/posts/:id</span>          <span class="comment">→ replace_post</span>
PATCH  <span class="str">/api/posts/:id</span>          <span class="comment">→ update_post</span>
DELETE <span class="str">/api/posts/:id</span>          <span class="comment">→ delete_post</span>
GET    <span class="str">/api/posts/:id/comments</span> <span class="comment">→ list_comments</span></code></pre>
            </section>

            <!-- 9. Request Flow -->
            <section id="request-flow" class="tutorial-section">
                <div class="section-number">28</div>
                <h2>Request Flow Through MVSR</h2>
                <p>Here's how a request flows through all MVSR layers:</p>

                <div class="callout">
                    <i data-lucide="arrow-right" class="inline-icon"></i>
                    <div>
                        <strong>HTTP Request</strong> → 
                        <strong>Router</strong> (matches path) → 
                        <strong>Handler</strong> (extracts & validates DTO) → 
                        <strong>Service</strong> (business logic) → 
                        <strong>Model</strong> (database ops) → 
                        <strong>DTO Response</strong> (serialize) → 
                        <strong>HTTP Response</strong>
                    </div>
                </div>

                <h3>Example: Complete Request</h3>
<pre><code><span class="comment">// 1. Incoming Request</span>
POST /api/blogs
{ "title": "Hello", "body": "World" }

<span class="comment">// 2. Router matches path → calls handler</span>
.route(<span class="str">"/api/blogs"</span>, <span class="fn">post</span>(handlers::create_blog))

<span class="comment">// 3. Handler extracts DTO</span>
<span class="kw">pub async fn</span> <span class="fn">create_blog</span>(
    State(state): State&lt;AppState&gt;,
    JsonBody(payload): JsonBody&lt;CreateBlogRequest&gt;,  <span class="comment">// ← DTO extracted</span>
) {
    <span class="comment">// 4. Handler calls service</span>
    <span class="kw">let</span> blog = services::create_one(&state.db, payload).<span class="kw">await</span>?;
    
    <span class="comment">// 7. Return response</span>
    <span class="type">Ok</span>((StatusCode::CREATED, Json(blog)))
}

<span class="comment">// 5. Service performs business logic</span>
<span class="kw">pub async fn</span> <span class="fn">create_one</span>(db: &DatabaseConnection, payload: CreateBlogRequest) {
    <span class="comment">// 6. Service uses Model to persist</span>
    <span class="kw">let</span> new = models::ActiveModel {
        title: Set(payload.title),
        body: Set(payload.body),
        ..Default::default()
    };
    new.insert(db).<span class="kw">await</span>?
}</code></pre>
            </section>

            <!-- 10. Testing Strategies -->
            <section id="testing" class="tutorial-section">
                <div class="section-number">29</div>
                <h2>Testing Strategies</h2>
                <p>The MVSR pattern makes testing easy. Test each layer independently.</p>

                <h3>Unit Testing Services</h3>
                <p>Services are pure functions — test them with just a database connection:</p>
<pre><code><span class="comment">// tests/blog_service_tests.rs</span>
<span class="attr">#[cfg(test)]</span>
<span class="kw">mod</span> tests {
    <span class="kw">use</span> chopin_core::testing::setup_test_db;
    <span class="kw">use</span> my_app::apps::blog::{services, dto::CreateBlogRequest};

    <span class="attr">#[tokio::test]</span>
    <span class="kw">async fn</span> <span class="fn">test_create_blog</span>() {
        <span class="kw">let</span> db = setup_test_db().<span class="kw">await</span>;
        <span class="kw">let</span> req = CreateBlogRequest {
            title: <span class="str">"Test"</span>.to_string(),
            body: <span class="str">"Content"</span>.to_string(),
        };
        <span class="kw">let</span> result = services::create_one(&db, req).<span class="kw">await</span>;
        assert!(result.is_ok());
        assert_eq!(result.unwrap().title, <span class="str">"Test"</span>);
    }

    <span class="attr">#[tokio::test]</span>
    <span class="kw">async fn</span> <span class="fn">test_find_nonexistent</span>() {
        <span class="kw">let</span> db = setup_test_db().<span class="kw">await</span>;
        <span class="kw">let</span> result = services::find_by_id(&db, <span class="num">999</span>).<span class="kw">await</span>;
        assert!(result.is_err());
    }
}</code></pre>

                <h3>Integration Testing</h3>
                <p>Test full request/response cycles with TestApp:</p>
<pre><code><span class="comment">// tests/blog_integration_tests.rs</span>
<span class="kw">use</span> chopin_core::testing::TestApp;

<span class="attr">#[tokio::test]</span>
<span class="kw">async fn</span> <span class="fn">test_create_and_get_blog</span>() {
    <span class="kw">let</span> app = TestApp::new().<span class="kw">await</span>;
    
    <span class="comment">// Create</span>
    <span class="kw">let</span> req = CreateBlogRequest {
        title: <span class="str">"Hello"</span>.to_string(),
        body: <span class="str">"World"</span>.to_string(),
    };
    <span class="kw">let</span> res = app.post(<span class="str">"/api/blogs"</span>, &req).<span class="kw">await</span>;
    assert_eq!(res.status, <span class="num">201</span>);
    
    <span class="comment">// Get</span>
    <span class="kw">let</span> blog: BlogResponse = res.json().<span class="kw">await</span>.unwrap();
    <span class="kw">let</span> get_res = app.get(&<span class="kw">format!</span>(<span class="str">"/api/blogs/{}"</span>, blog.id)).<span class="kw">await</span>;
    assert_eq!(get_res.status, <span class="num">200</span>);
    
    <span class="comment">// Update</span>
    <span class="kw">let</span> patch_res = app.patch(<span class="str">"/api/blogs/1"</span>, &req).<span class="kw">await</span>;
    assert_eq!(patch_res.status, <span class="num">200</span>);
    
    <span class="comment">// Delete</span>
    <span class="kw">let</span> del_res = app.delete(<span class="str">"/api/blogs/1"</span>).<span class="kw">await</span>;
    assert_eq!(del_res.status, <span class="num">200</span>);
}</code></pre>

                <div class="callout">
                    <i data-lucide="check-square" class="inline-icon"></i>
                    <div>
                        <strong>Testing Strategy:</strong> Write unit tests for services (fast, no HTTP). Write integration tests for critical user flows (slower, full stack).
                    </div>
                </div>
            </section>

            <!-- 11. ChopinModule Trait -->
            <section id="chopin-module" class="tutorial-section">
                <div class="section-number">30</div>
                <h2>The ChopinModule Trait</h2>
                <p>Every module implements the <code>ChopinModule</code> trait, which defines a standard contract for module composition:</p>

<pre><code><span class="kw">use</span> async_trait::async_trait;
<span class="kw">use</span> axum::Router;

<span class="attr">#[async_trait]</span>
<span class="kw">pub trait</span> <span class="type">ChopinModule</span>: Send + Sync {
    <span class="doc">/// Unique module name (e.g., "blog", "billing")</span>
    <span class="kw">fn</span> <span class="fn">name</span>(&self) -> &<span class="type">str</span>;

    <span class="doc">/// Return an Axum Router with all module routes</span>
    <span class="kw">fn</span> <span class="fn">routes</span>(&self) -> Router&lt;AppState&gt;;

    <span class="doc">/// Run module-specific database migrations</span>
    <span class="kw">async fn</span> <span class="fn">migrate</span>(&self, db: &DatabaseConnection) -> <span class="type">Result</span>&lt;(), ChopinError&gt;;

    <span class="doc">/// Optional: health check for this module</span>
    <span class="kw">async fn</span> <span class="fn">health_check</span>(&self) -> <span class="type">Result</span>&lt;(), ChopinError&gt; {
        <span class="type">Ok</span>(()) <span class="comment">// default: always healthy</span>
    }

    <span class="doc">/// Optional: provide OpenAPI spec for this module</span>
    <span class="kw">fn</span> <span class="fn">openapi_spec</span>(&self) -> Option&lt;utoipa::openapi::OpenApi&gt; {
        None <span class="comment">// default: no API docs</span>
    }
}</code></pre>

                <h3>Implementing ChopinModule</h3>
<pre><code><span class="comment">// src/apps/blog/mod.rs</span>
<span class="kw">use</span> async_trait::async_trait;
<span class="kw">use</span> axum::Router;
<span class="kw">use</span> chopin_core::controllers::AppState;
<span class="kw">use</span> chopin_core::error::ChopinError;
<span class="kw">use</span> chopin_core::module::ChopinModule;
<span class="kw">use</span> sea_orm::DatabaseConnection;

<span class="kw">mod</span> dto;
<span class="kw">mod</span> handlers;
<span class="kw">mod</span> models;
<span class="kw">mod</span> routes;
<span class="kw">mod</span> services;

<span class="kw">pub use</span> dto::*;
<span class="kw">pub use</span> models::*;

<span class="kw">pub struct</span> <span class="type">BlogModule</span>;

<span class="kw">impl</span> <span class="type">BlogModule</span> {
    <span class="kw">pub fn</span> <span class="fn">new</span>() -> <span class="type">Self</span> { <span class="type">Self</span> }
}

<span class="attr">#[async_trait]</span>
<span class="kw">impl</span> ChopinModule <span class="kw">for</span> <span class="type">BlogModule</span> {
    <span class="kw">fn</span> <span class="fn">name</span>(&self) -> &<span class="type">str</span> { <span class="str">"blog"</span> }

    <span class="kw">fn</span> <span class="fn">routes</span>(&self) -> Router&lt;AppState&gt; {
        routes::routes()
    }

    <span class="kw">async fn</span> <span class="fn">migrate</span>(&self, _db: &DatabaseConnection) -> <span class="type">Result</span>&lt;(), ChopinError&gt; {
        <span class="comment">// Add module-specific migrations here</span>
        <span class="type">Ok</span>(())
    }
}</code></pre>
            </section>

            <!-- 12. Mounting & Composition -->
            <section id="mounting" class="tutorial-section">
                <div class="section-number">31</div>
                <h2>Mounting & Composition</h2>
                <p>The <code>main.rs</code> file is the "Composer" that assembles all modules into one application. Use <code>mount_module()</code> to add each module:</p>

<pre><code><span class="comment">// src/main.rs — The "Composer"</span>
<span class="kw">use</span> chopin_core::prelude::*;

<span class="kw">mod</span> apps;

<span class="attr">#[tokio::main]</span>
<span class="kw">async fn</span> <span class="fn">main</span>() -> <span class="type">Result</span>&lt;(), Box&lt;<span class="kw">dyn</span> std::error::Error&gt;&gt; {
    init_logging();

    <span class="kw">let</span> app = App::new().<span class="kw">await</span>?;
    <span class="comment">// AuthModule is mounted by default.</span>
    <span class="comment">// Mount your feature modules:</span>
    <span class="kw">let</span> app = app.mount_module(apps::blog::BlogModule::new());
    <span class="kw">let</span> app = app.mount_module(apps::billing::BillingModule::new());
    <span class="kw">let</span> app = app.mount_module(apps::inventory::InventoryModule::new());

    app.run().<span class="kw">await</span>?;
    <span class="type">Ok</span>(())
}</code></pre>

                <h3>Module registry</h3>
<pre><code><span class="comment">// src/apps/mod.rs</span>
<span class="kw">pub mod</span> blog;
<span class="kw">pub mod</span> billing;
<span class="kw">pub mod</span> inventory;</code></pre>

                <div class="callout">
                    <i data-lucide="info" class="inline-icon"></i>
                    <div>
                        <strong>Automatic wiring:</strong> When you run <code>chopin startapp billing</code>, the CLI automatically adds <code>pub mod billing;</code> to <code>src/apps/mod.rs</code> and the <code>mount_module()</code> call to <code>src/main.rs</code>.
                    </div>
                </div>
            </section>

            <!-- 13. Best Practices -->
            <section id="best-practices" class="tutorial-section">
                <div class="section-number">32</div>
                <h2>Best Practices</h2>

                <h3>Module dependency rules</h3>
                <table>
                    <thead>
                        <tr><th>Allowed</th><th>Forbidden</th></tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Module → <code>chopin-core</code></td>
                            <td>Module → another Module</td>
                        </tr>
                        <tr>
                            <td>Module → <code>src/shared/</code></td>
                            <td>Module → <code>src/main.rs</code></td>
                        </tr>
                        <tr>
                            <td>Handler → Service</td>
                            <td>Service → Handler</td>
                        </tr>
                    </tbody>
                </table>

                <h3>When to create a new module</h3>
                <ul>
                    <li>A new business domain (blog, billing, notifications)</li>
                    <li>A set of related endpoints that share the same models</li>
                    <li>A feature that could be developed/tested independently</li>
                </ul>

                <h3>When to use <code>src/shared/</code></h3>
                <ul>
                    <li>Common DTOs (e.g., <code>PaginatedResponse</code>)</li>
                    <li>Shared permission enums</li>
                    <li>Cross-cutting middleware</li>
                    <li>Utility functions used by multiple modules</li>
                </ul>

                <h3>Testing modules</h3>
<pre><code><span class="comment">// tests/blog_tests.rs</span>
<span class="kw">use</span> chopin_core::testing::TestApp;

<span class="attr">#[tokio::test]</span>
<span class="kw">async fn</span> <span class="fn">test_blog_list</span>() {
    <span class="kw">let</span> app = TestApp::new().<span class="kw">await</span>;
    <span class="kw">let</span> res = app.get(<span class="str">"/api/blogs"</span>).<span class="kw">await</span>;
    assert_eq!(res.status, <span class="num">200</span>);
}

<span class="attr">#[tokio::test]</span>
<span class="kw">async fn</span> <span class="fn">test_blog_not_found</span>() {
    <span class="kw">let</span> app = TestApp::new().<span class="kw">await</span>;
    <span class="kw">let</span> res = app.get(<span class="str">"/api/blogs/999"</span>).<span class="kw">await</span>;
    assert_eq!(res.status, <span class="num">404</span>);
}</code></pre>

                <p><code>chopin startapp</code> automatically generates these test stubs for you.</p>
            </section>

            <!-- Navigation -->
            <nav class="tutorial-nav">
                <a href="tutorial-deployment.html" class="btn-secondary">&larr; Deployment</a>
                <a href="tutorial-index.html" class="btn-primary">Back to Index</a>
            </nav>

        </main>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-bottom" style="border-top: none; padding-top: 0;">
                <div class="footer-bottom-left">
                    <p>&copy; 2026 Chopin. All rights reserved.</p>
                </div>
                <div class="footer-bottom-right">
                    <p>Made with <i data-lucide="music" class="inline-icon-sm"></i> by the <a href="https://github.com/kowito">Chopin team</a></p>
                </div>
            </div>
        </div>
    </footer>

    <script src="js/main.js"></script>
    <script>
        lucide.createIcons();

        const sections = document.querySelectorAll('.tutorial-section');
        const tocLinks = document.querySelectorAll('.toc-link');

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    tocLinks.forEach(link => link.classList.remove('active'));
                    const id = entry.target.getAttribute('id');
                    const activeLink = document.querySelector(`.toc-link[href="#${id}"]`);
                    if (activeLink) activeLink.classList.add('active');
                }
            });
        }, { rootMargin: '-80px 0px -60% 0px' });

        sections.forEach(section => observer.observe(section));
    </script>
</body>
</html>
