<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Chopin Tutorial - Building APIs with Controllers, Authentication, Security, Extractors, and Error Handling.">
    <title>Tutorial: Building APIs - Chopin Framework</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/tutorial.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&family=Caveat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
</head>
<body>
    <!-- Navigation -->
    <nav class="nav">
        <div class="container">
            <div class="nav-content">
                <div class="nav-logo">
                    <a href="index.html" style="display:flex;align-items:center;gap:0.75rem;text-decoration:none;color:inherit;">
                        <i data-lucide="music" class="logo-icon"></i>
                        <span class="logo-text">Chopin</span>
                    </a>
                </div>
                <div class="nav-links">
                    <a href="index.html#features">Features</a>
                    <a href="index.html#benchmarks">Benchmarks</a>
                    <a href="tutorial-index.html">Tutorial</a>
                    <a href="https://docs.rs/chopin">API Docs</a>
                    <a href="https://github.com/kowito/chopin" class="btn-primary">GitHub</a>
                </div>
            </div>
        </div>
    </nav>

    <div class="tutorial-layout">
        <!-- Sidebar TOC -->
        <aside class="tutorial-sidebar">
            <div class="toc">
                <h3 class="toc-title">Building APIs</h3>
                <ol class="toc-list">
                    <li><a href="#modules" class="toc-link">Quick Module Overview</a></li>
                    <li><a href="#authentication" class="toc-link">Authentication</a></li>
                    <li><a href="#security" class="toc-link">Security Features</a></li>
                    <li><a href="#roles" class="toc-link">Roles & Permissions</a></li>
                    <li><a href="#extractors" class="toc-link">Extractors</a></li>
                    <li><a href="#pagination" class="toc-link">Pagination</a></li>
                    <li><a href="#error-handling" class="toc-link">Error Handling</a></li>
                </ol>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="tutorial-content">

            <!-- Hero -->
            <div class="tutorial-hero">
                <h1>Building APIs with Chopin</h1>
                <p>Implement authentication, manage roles, extract request data, and handle errors. Learn the API patterns that make Chopin productive.</p>
                <div class="page-indicator">Page 3 of 7</div>
            </div>

            <!-- 1. Quick Module Overview -->
            <section id="modules" class="tutorial-section">
                <div class="section-number">07</div>
                <h2>Working with Modules</h2>
                <p>Chopin organizes code into <strong>feature modules</strong> using the <strong>MVSR pattern</strong> (Model–View–Service–Router). Create a module with one command, then build your API handlers inside it.</p>

                <h3>Create a module</h3>
<pre><code><span class="comment"># Generate a complete module with MVSR scaffold</span>
chopin startapp blog

<span class="comment"># Auto-generates and registers everything you need</span></code></pre>

                <div class="callout">
                    <i data-lucide="info" class="inline-icon"></i>
                    <div>
                        <strong>Need more details?</strong> See the <a href="tutorial-modules.html">Modular Architecture</a> guide for a deep dive into the MVSR pattern, ChopinModule trait, and hub-and-spoke composition.
                    </div>
                </div>

                <h3>Handler example</h3>
                <p>Handlers are thin adapters that extract request data, call services, and return responses:</p>

<pre><code><span class="comment">// src/apps/blog/handlers.rs</span>
<span class="kw">use</span> axum::extract::{Path, State};
<span class="kw">use</span> chopin_core::prelude::*;

<span class="kw">pub async fn</span> <span class="fn">get_post</span>(
    State(state): State&lt;AppState&gt;,
    Path(id): Path&lt;<span class="type">i32</span>&gt;,
) -> <span class="type">Result</span>&lt;Json&lt;ApiResponse&lt;PostResponse&gt;&gt;, ChopinError&gt; {
    <span class="kw">let</span> post = services::find_by_id(&state.db, id).<span class="kw">await</span>?;
    <span class="type">Ok</span>(Json(ApiResponse::success(post)))
}</code></pre>

                <h3>Application state</h3>
<pre><code><span class="comment">// Available in all handlers via State extractor</span>
<span class="kw">pub struct</span> <span class="type">AppState</span> {
    <span class="kw">pub</span> db: DatabaseConnection,       <span class="comment">// Database connection</span>
    <span class="kw">pub</span> config: Config,               <span class="comment">// App configuration</span>
    <span class="kw">pub</span> cache: Option&lt;CacheService&gt;,  <span class="comment">// Optional caching</span>
}</code></pre>
            </section>

            <!-- 2. Authentication -->
            <section id="authentication" class="tutorial-section">
                <div class="section-number">08</div>
                <h2>Authentication</h2>
                <p>Chopin provides <strong>built-in JWT authentication</strong> with Argon2id password hashing. The <code>/api/auth/signup</code> and <code>/api/auth/login</code> endpoints are included automatically.</p>

                <h3>Sign up a user</h3>
<pre><code>curl -X POST http://localhost:3000/api/auth/signup \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "password": "securepassword123",
    "name": "John Doe"
  }'

<span class="comment"># Response:</span>
<span class="comment"># {</span>
<span class="comment">#   "success": true,</span>
<span class="comment">#   "data": {</span>
<span class="comment">#     "token": "eyJhbGciOiJIUzI1...",</span>
<span class="comment">#     "user": { "id": "uuid", "email": "user@example.com", "name": "John Doe", "role": "user" }</span>
<span class="comment">#   }</span>
<span class="comment"># }</span></code></pre>

                <h3>Log in</h3>
<pre><code>curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "password": "securepassword123"
  }'</code></pre>

                <h3>How it works internally</h3>
<pre><code><span class="comment">// Passwords are hashed with Argon2id (memory-hard, GPU-resistant)</span>
<span class="kw">use</span> chopin_core::auth::password;

<span class="kw">let</span> hash = password::hash_password(<span class="str">"my-password"</span>)?;
<span class="kw">let</span> valid = password::verify_password(<span class="str">"my-password"</span>, &hash)?;

<span class="comment">// JWTs are signed with HS256</span>
<span class="kw">use</span> chopin_core::auth::jwt;

<span class="kw">let</span> token = jwt::create_token(
    &user_id,             <span class="comment">// UUID string</span>
    &email,
    &role,                <span class="comment">// "user", "admin", "superuser"</span>
    &config.jwt_secret,
    config.jwt_expiry_hours,
)?;

<span class="kw">let</span> claims = jwt::validate_token(&token, &config.jwt_secret)?;
<span class="comment">// claims.sub = user_id, claims.email, claims.role</span></code></pre>
            </section>

            <!-- 3. Security Features -->
            <section id="security" class="tutorial-section">
                <div class="section-number">08b</div>
                <h2>Security Features</h2>
                <p>Chopin includes <strong>9 production security features</strong>, all <strong>enabled by default</strong>. No extra code or config needed — just deploy. Each feature can be individually disabled via environment variables.</p>

                <h3>Overview</h3>
                <table class="config-table">
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>What It Does</th>
                            <th>Env Var to Disable</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td><strong>2FA/TOTP</strong></td><td>Time-based One-Time Password</td><td><code>SECURITY_2FA=false</code></td></tr>
                        <tr><td><strong>Rate Limiting</strong></td><td>Blocks login after 5 attempts per 5 min</td><td><code>SECURITY_RATE_LIMIT=false</code></td></tr>
                        <tr><td><strong>Account Lockout</strong></td><td>Locks account after 5 failed attempts</td><td><code>SECURITY_ACCOUNT_LOCKOUT=false</code></td></tr>
                        <tr><td><strong>Refresh Tokens</strong></td><td>Automatic rotation with reuse detection</td><td><code>SECURITY_REFRESH_TOKENS=false</code></td></tr>
                        <tr><td><strong>Session Management</strong></td><td>Server-side sessions, revoke one or all</td><td><code>SECURITY_SESSION_MANAGEMENT=false</code></td></tr>
                        <tr><td><strong>Password Reset</strong></td><td>Secure token-based password reset</td><td><code>SECURITY_PASSWORD_RESET=false</code></td></tr>
                        <tr><td><strong>Email Verification</strong></td><td>Require email verification on signup</td><td><code>SECURITY_EMAIL_VERIFICATION=false</code></td></tr>
                        <tr><td><strong>CSRF Protection</strong></td><td>Token verified on state-changing requests</td><td><code>SECURITY_CSRF=false</code></td></tr>
                        <tr><td><strong>IP/Device Tracking</strong></td><td>Audit log of all login events</td><td><code>SECURITY_DEVICE_TRACKING=false</code></td></tr>
                    </tbody>
                </table>

                <h3>2FA / TOTP Setup Flow</h3>
<pre><code><span class="comment"># 1. Setup — get the TOTP secret and QR code URI</span>
curl -X POST http://localhost:3000/api/auth/totp/setup \
  -H "Authorization: Bearer &lt;token&gt;"

<span class="comment"># 2. User scans QR code in Google Authenticator / Authy</span>
<span class="comment"># 3. Verify and enable with a code from the app:</span>
curl -X POST http://localhost:3000/api/auth/totp/enable \
  -H "Authorization: Bearer &lt;token&gt;" \
  -H "Content-Type: application/json" \
  -d '{ "code": "123456" }'

<span class="comment"># Future logins now require the totp_code field:</span>
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{ "email": "user@example.com", "password": "pw", "totp_code": "654321" }'</code></pre>

                <h3>Logout & Session Revocation</h3>
<pre><code><span class="comment"># Logout current session</span>
curl -X POST http://localhost:3000/api/auth/logout \
  -H "Authorization: Bearer &lt;token&gt;" \
  -H "Content-Type: application/json" \
  -d '{ "all_sessions": false }'

<span class="comment"># Logout everywhere (revoke ALL sessions)</span>
curl -X POST http://localhost:3000/api/auth/logout \
  -H "Authorization: Bearer &lt;token&gt;" \
  -H "Content-Type: application/json" \
  -d '{ "all_sessions": true }'</code></pre>
            </section>

            <!-- 4. Roles & Permissions -->
            <section id="roles" class="tutorial-section">
                <div class="section-number">09</div>
                <h2>Roles & Permissions</h2>
                <p>Chopin has a simple but effective <strong>hierarchical role system</strong>. Higher roles inherit all permissions of lower roles.</p>

                <div class="role-hierarchy">
                    <div class="role-card">
                        <div class="role-level">Level 0</div>
                        <h4>User</h4>
                        <p>Default role for new accounts</p>
                    </div>
                    <div class="role-arrow">&rarr;</div>
                    <div class="role-card">
                        <div class="role-level">Level 1</div>
                        <h4>Admin</h4>
                        <p>Can do everything User can + admin actions</p>
                    </div>
                    <div class="role-arrow">&rarr;</div>
                    <div class="role-card">
                        <div class="role-level">Level 2</div>
                        <h4>Superuser</h4>
                        <p>Full access to everything</p>
                    </div>
                </div>

                <h3>Protect routes by role</h3>
<pre><code><span class="kw">use</span> chopin_core::extractors::AuthUserWithRole;
<span class="kw">use</span> chopin_core::models::user::Role;

<span class="comment">// Only admins and superusers can access this</span>
<span class="kw">pub async fn</span> <span class="fn">admin_dashboard</span>(
    user: AuthUserWithRole&lt;{ Role::Admin <span class="kw">as</span> u8 }&gt;,
) -> <span class="kw">impl</span> IntoResponse {
    <span class="comment">// user.user_id, user.email, user.role are available</span>
    chopin_core::Json(json!({ "message": "Welcome, admin!" }))
}

<span class="comment">// Or use the require_role middleware on a group of routes</span>
<span class="kw">use</span> chopin_core::extractors::require_role;

<span class="kw">fn</span> <span class="fn">admin_routes</span>() -> Router&lt;AppState&gt; {
    Router::new()
        .route(<span class="str">"/api/admin/users"</span>, get(list_users))
        .route(<span class="str">"/api/admin/stats"</span>, get(admin_stats))
        .layer(chopin_core::middleware::from_fn(require_role::&lt;{ Role::Admin <span class="kw">as</span> u8 }&gt;))
}</code></pre>

                <h3>Create a superuser</h3>
<pre><code><span class="comment"># Via CLI</span>
chopin createsuperuser</code></pre>
            </section>

            <!-- 5. Extractors -->
            <section id="extractors" class="tutorial-section">
                <div class="section-number">10</div>
                <h2>Extractors</h2>
                <p>Extractors are Axum's way of parsing request data. Chopin provides custom extractors for common patterns.</p>

                <h3>AuthUser — JWT authentication</h3>
<pre><code><span class="kw">use</span> chopin_core::extractors::AuthUser;

<span class="comment">// Automatically validates the Bearer token from Authorization header</span>
<span class="kw">pub async fn</span> <span class="fn">get_profile</span>(user: AuthUser) -> <span class="kw">impl</span> IntoResponse {
    <span class="comment">// user.user_id: String (UUID)</span>
    <span class="comment">// user.email: String</span>
    <span class="comment">// user.role: String</span>
    chopin_core::Json(json!({
        "id": user.user_id,
        "email": user.email,
        "role": user.role,
    }))
}</code></pre>

                <h3>Json — SIMD-accelerated body parsing</h3>
<pre><code><span class="kw">use</span> chopin_core::extractors::Json;

<span class="comment">// When `perf` feature is enabled, uses sonic-rs (SIMD)</span>
<span class="comment">// Otherwise falls back to serde_json</span>
<span class="kw">pub async fn</span> <span class="fn">create_item</span>(
    Json(payload): Json&lt;CreateItemRequest&gt;,
) -> <span class="kw">impl</span> IntoResponse {
    <span class="comment">// payload is deserialized from request body</span>
}</code></pre>

                <h3>Pagination — query parameter extraction</h3>
<pre><code><span class="kw">use</span> chopin_core::extractors::Pagination;

<span class="comment">// GET /api/posts?page=2&per_page=20</span>
<span class="kw">pub async fn</span> <span class="fn">list_items</span>(
    Query(pagination): Query&lt;Pagination&gt;,
) {
    <span class="kw">let</span> p = pagination.clamped(); <span class="comment">// Enforces min/max</span>
    <span class="comment">// p.page: clamped to 1..10000</span>
    <span class="comment">// p.per_page: clamped to 1..100</span>
    <span class="comment">// p.offset: computed as (page - 1) * per_page</span>
    <span class="comment">// p.limit: same as per_page</span>
}</code></pre>
            </section>

            <!-- 6. Pagination -->
            <section id="pagination" class="tutorial-section">
                <div class="section-number">11</div>
                <h2>Pagination</h2>
                <p>Chopin provides a complete pagination system with clamped values and a standardized response format.</p>

<pre><code><span class="kw">use</span> chopin_core::extractors::{Pagination, PaginatedResponse};

<span class="kw">pub async fn</span> <span class="fn">list_posts</span>(
    State(state): State&lt;AppState&gt;,
    Query(pagination): Query&lt;Pagination&gt;,
) -> chopin_core::Json&lt;PaginatedResponse&lt;PostResponse&gt;&gt; {
    <span class="kw">let</span> p = pagination.clamped();

    <span class="comment">// Count total items</span>
    <span class="kw">let</span> total = Post::find().count(&state.db).<span class="kw">await</span>.unwrap_or(<span class="num">0</span>);

    <span class="comment">// Fetch page</span>
    <span class="kw">let</span> items = Post::find()
        .offset(p.offset)
        .limit(p.limit)
        .all(&state.db).<span class="kw">await</span>.unwrap_or_default()
        .into_iter().map(PostResponse::from).collect();

    chopin_core::Json(PaginatedResponse::new(items, total, p.page, p.per_page))
}</code></pre>

                <p>Response format:</p>
<pre><code><span class="comment">// {</span>
<span class="comment">//   "data": [...],</span>
<span class="comment">//   "pagination": {</span>
<span class="comment">//     "page": 1,</span>
<span class="comment">//     "per_page": 20,</span>
<span class="comment">//     "total": 150,</span>
<span class="comment">//     "total_pages": 8</span>
<span class="comment">//   }</span>
<span class="comment">// }</span></code></pre>
            </section>

            <!-- 7. Error Handling -->
            <section id="error-handling" class="tutorial-section">
                <div class="section-number">12</div>
                <h2>Error Handling</h2>
                <p>Chopin provides a unified error type that automatically maps to HTTP status codes and JSON responses.</p>

<pre><code><span class="kw">use</span> chopin_core::error::{ChopinError, FieldError};

<span class="comment">// Each variant maps to an HTTP status code</span>
ChopinError::NotFound(<span class="str">"User not found"</span>.into())         <span class="comment">// 404</span>
ChopinError::BadRequest(<span class="str">"Invalid input"</span>.into())         <span class="comment">// 400</span>
ChopinError::Unauthorized(<span class="str">"Invalid token"</span>.into())       <span class="comment">// 401</span>
ChopinError::Forbidden(<span class="str">"Not allowed"</span>.into())            <span class="comment">// 403</span>
ChopinError::Conflict(<span class="str">"Email already exists"</span>.into())   <span class="comment">// 409</span>
ChopinError::Internal(<span class="str">"Something broke"</span>.into())        <span class="comment">// 500</span>

<span class="comment">// All errors produce consistent JSON:</span>
<span class="comment">// { "success": false, "error": "User not found" }</span></code></pre>

                <h3>Field-level validation errors</h3>
<pre><code><span class="comment">// Return multiple field errors at once</span>
<span class="kw">let</span> errors = <span class="kw">vec!</span>[
    FieldError::new(<span class="str">"email"</span>, <span class="str">"must be a valid email address"</span>),
    FieldError::new(<span class="str">"password"</span>, <span class="str">"must be at least 8 characters"</span>),
];
<span class="kw">return</span> Err(ChopinError::ValidationErrors(errors));

<span class="comment">// Response (422):</span>
<span class="comment">// {</span>
<span class="comment">//   "success": false,</span>
<span class="comment">//   "error": "Validation failed",</span>
<span class="comment">//   "fields": [</span>
<span class="comment">//     { "field": "email", "message": "must be a valid email address" },</span>
<span class="comment">//     { "field": "password", "message": "must be at least 8 characters" }</span>
<span class="comment">//   ]</span>
<span class="comment">// }</span></code></pre>

                <h3>Using in handlers</h3>
<pre><code><span class="kw">use</span> chopin_core::error::ChopinError;
<span class="kw">use</span> chopin_core::response::ApiResponse;

<span class="kw">pub async fn</span> <span class="fn">get_post</span>(
    State(state): State&lt;AppState&gt;,
    Path(id): Path&lt;<span class="type">i32</span>&gt;,
) -> <span class="type">Result</span>&lt;chopin_core::Json&lt;ApiResponse&lt;PostResponse&gt;&gt;, ChopinError&gt; {
    <span class="kw">let</span> post = Post::find_by_id(id)
        .one(&state.db).<span class="kw">await</span>
        .map_err(|e| ChopinError::Database(e.to_string()))?
        .ok_or_else(|| ChopinError::NotFound(<span class="kw">format!</span>(<span class="str">"Post {} not found"</span>, id)))?;

    <span class="type">Ok</span>(chopin_core::Json(ApiResponse::success(PostResponse::from(post))))
}</code></pre>
            </section>

            <!-- Navigation -->
            <nav class="tutorial-nav">
                <a href="tutorial-database.html" class="btn-secondary">&larr; Database</a>
                <a href="tutorial-advanced.html" class="btn-primary">Next: Advanced →</a>
            </nav>

        </main>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-bottom" style="border-top: none; padding-top: 0;">
                <div class="footer-bottom-left">
                    <p>&copy; 2026 Chopin. All rights reserved.</p>
                </div>
                <div class="footer-bottom-right">
                    <p>Made with <i data-lucide="music" class="inline-icon-sm"></i> by the <a href="https://github.com/kowito">Chopin team</a></p>
                </div>
            </div>
        </div>
    </footer>

    <script src="js/main.js"></script>
    <script>
        lucide.createIcons();

        const sections = document.querySelectorAll('.tutorial-section');
        const tocLinks = document.querySelectorAll('.toc-link');

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    tocLinks.forEach(link => link.classList.remove('active'));
                    const id = entry.target.getAttribute('id');
                    const activeLink = document.querySelector(`.toc-link[href="#${id}"]`);
                    if (activeLink) activeLink.classList.add('active');
                }
            });
        }, { rootMargin: '-80px 0px -60% 0px' });

        sections.forEach(section => observer.observe(section));
    </script>
</body>
</html>
