<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Chopin Tutorial - Building APIs with Controllers, Authentication, Security, Extractors, and Error Handling.">
    <title>Tutorial: Building APIs - Chopin Framework</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/tutorial.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&family=Caveat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
</head>
<body>
    <!-- Navigation -->
    <nav class="nav">
        <div class="container">
            <div class="nav-content">
                <div class="nav-logo">
                    <a href="index.html" style="display:flex;align-items:center;gap:0.75rem;text-decoration:none;color:inherit;">
                        <i data-lucide="music" class="logo-icon"></i>
                        <span class="logo-text">Chopin</span>
                    </a>
                </div>
                <div class="nav-links">
                    <a href="index.html#features">Features</a>
                    <a href="index.html#benchmarks">Benchmarks</a>
                    <a href="tutorial-index.html">Tutorial</a>
                    <a href="https://docs.rs/chopin">API Docs</a>
                    <a href="https://github.com/kowito/chopin" class="btn-primary">GitHub</a>
                </div>
            </div>
        </div>
    </nav>

    <div class="tutorial-layout">
        <!-- Sidebar TOC -->
        <aside class="tutorial-sidebar">
            <div class="toc">
                <h3 class="toc-title">Building APIs</h3>
                <ol class="toc-list">
                    <li><a href="#modules" class="toc-link">Modules & Routing (MVSR)</a></li>
                    <li><a href="#authentication" class="toc-link">Authentication</a></li>
                    <li><a href="#security" class="toc-link">Security Features</a></li>
                    <li><a href="#roles" class="toc-link">Roles & Permissions</a></li>
                    <li><a href="#extractors" class="toc-link">Extractors</a></li>
                    <li><a href="#pagination" class="toc-link">Pagination</a></li>
                    <li><a href="#error-handling" class="toc-link">Error Handling</a></li>
                </ol>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="tutorial-content">

            <!-- Hero -->
            <div class="tutorial-hero">
                <h1>Building APIs with Chopin</h1>
                <p>Create feature modules with the MVSR pattern, implement authentication, manage roles, extract request data, and handle errors — all with minimal code.</p>
                <div class="page-indicator">Page 3 of 7</div>
            </div>

            <!-- 1. Modules & Routing (MVSR) -->
            <section id="modules" class="tutorial-section">
                <div class="section-number">07</div>
                <h2>Modules & Routing (MVSR)</h2>
                <p>Chopin organises code into <strong>feature modules</strong> using the <strong>MVSR pattern</strong> (Model–View/Handler–Service–Router). Each module is a self-contained folder under <code>src/apps/</code>, inspired by Django's <code>startapp</code>.</p>

                <div class="callout">
                    <i data-lucide="info" class="inline-icon"></i>
                    <div>
                        <strong>Why modules?</strong> Each feature (blog, billing, inventory) lives in its own folder with its own routes, handlers, services, models, and DTOs. Modules never depend on each other — only on <code>chopin-core</code> and <code>src/shared/</code>.
                    </div>
                </div>

                <h3>Create a module (Django-style)</h3>
<pre><code><span class="comment"># Create a blog module with full MVSR scaffold</span>
chopin startapp blog

<span class="comment"># This creates src/apps/blog/ with:</span>
<span class="comment">#   mod.rs        — ChopinModule trait implementation</span>
<span class="comment">#   handlers.rs   — HTTP handler functions (thin adapters)</span>
<span class="comment">#   services.rs   — Pure business logic (unit-testable)</span>
<span class="comment">#   routes.rs     — Route definitions</span>
<span class="comment">#   dto.rs        — Request/response types</span>
<span class="comment">#   models.rs     — SeaORM entities</span>
<span class="comment">#</span>
<span class="comment"># Auto-registers in src/apps/mod.rs and mounts in src/main.rs!</span></code></pre>

                <h3>Application state</h3>
<pre><code><span class="comment">// Chopin provides this built-in:</span>
<span class="attr">#[derive(Clone)]</span>
<span class="kw">pub struct</span> <span class="type">AppState</span> {
    <span class="kw">pub</span> db: DatabaseConnection,
    <span class="kw">pub</span> config: Config,
    <span class="kw">pub</span> cache: Option&lt;CacheService&gt;,
}</code></pre>

                <h3>Module structure</h3>
                <p>Here's what a complete blog module looks like:</p>

<h4>src/apps/blog/routes.rs</h4>
<pre><code><span class="kw">use</span> axum::Router;
<span class="kw">use</span> chopin_core::controllers::AppState;
<span class="kw">use</span> chopin_core::routing::{get, post, put, delete};
<span class="kw">use</span> super::handlers;

<span class="kw">pub fn</span> <span class="fn">routes</span>() -> Router&lt;AppState&gt; {
    Router::new().nest(
        <span class="str">"/api/blogs"</span>,
        Router::new()
            .route(<span class="str">"/"</span>, get(handlers::list).post(handlers::create))
            .route(<span class="str">"/{id}"</span>, get(handlers::get_by_id).put(handlers::update).delete(handlers::remove)),
    )
}</code></pre>

<h4>src/apps/blog/handlers.rs</h4>
<pre><code><span class="comment">// Handlers are thin adapters: extract request → call service → return response</span>
<span class="kw">use</span> axum::extract::{Path, State};
<span class="kw">use</span> chopin_core::controllers::AppState;
<span class="kw">use</span> chopin_core::error::ChopinError;
<span class="kw">use</span> chopin_core::extractors::Json;
<span class="kw">use</span> chopin_core::response::ApiResponse;
<span class="kw">use</span> super::{dto::*, services};

<span class="kw">pub async fn</span> <span class="fn">list</span>(
    State(state): State&lt;AppState&gt;,
) -> <span class="type">Result</span>&lt;Json&lt;ApiResponse&lt;Vec&lt;BlogResponse&gt;&gt;&gt;, ChopinError&gt; {
    <span class="kw">let</span> items = services::list_all(&state.db).<span class="kw">await</span>?;
    <span class="type">Ok</span>(Json(ApiResponse::success(items)))
}

<span class="kw">pub async fn</span> <span class="fn">create</span>(
    State(state): State&lt;AppState&gt;,
    Json(payload): Json&lt;CreateBlogRequest&gt;,
) -> <span class="type">Result</span>&lt;Json&lt;ApiResponse&lt;BlogResponse&gt;&gt;, ChopinError&gt; {
    <span class="kw">let</span> item = services::create_one(&state.db, payload).<span class="kw">await</span>?;
    <span class="type">Ok</span>(Json(ApiResponse::success(item)))
}</code></pre>

<h4>src/apps/blog/services.rs</h4>
<pre><code><span class="comment">// Services are pure Rust functions — no HTTP types.</span>
<span class="comment">// Receive a DatabaseConnection, return domain types.</span>
<span class="comment">// 100% unit-testable without a running server.</span>
<span class="kw">use</span> chopin_core::error::ChopinError;
<span class="kw">use</span> sea_orm::*;
<span class="kw">use</span> super::dto::*;
<span class="kw">use</span> super::models::{self, Entity <span class="kw">as</span> Blog};

<span class="kw">pub async fn</span> <span class="fn">list_all</span>(db: &DatabaseConnection) -> <span class="type">Result</span>&lt;Vec&lt;BlogResponse&gt;, ChopinError&gt; {
    <span class="kw">let</span> items = Blog::find().all(db).<span class="kw">await</span>
        .map_err(|e| ChopinError::Database(e.to_string()))?;
    <span class="type">Ok</span>(items.into_iter().map(BlogResponse::from).collect())
}

<span class="kw">pub async fn</span> <span class="fn">create_one</span>(
    db: &DatabaseConnection,
    payload: CreateBlogRequest,
) -> <span class="type">Result</span>&lt;BlogResponse, ChopinError&gt; {
    <span class="kw">let</span> new = models::ActiveModel {
        title: Set(payload.title),
        body: Set(payload.body),
        ..Default::default()
    };
    <span class="kw">let</span> result = new.insert(db).<span class="kw">await</span>
        .map_err(|e| ChopinError::Database(e.to_string()))?;
    <span class="type">Ok</span>(BlogResponse::from(result))
}</code></pre>

<h4>src/apps/blog/mod.rs — ChopinModule</h4>
<pre><code><span class="kw">use</span> async_trait::async_trait;
<span class="kw">use</span> axum::Router;
<span class="kw">use</span> chopin_core::controllers::AppState;
<span class="kw">use</span> chopin_core::error::ChopinError;
<span class="kw">use</span> chopin_core::module::ChopinModule;
<span class="kw">use</span> sea_orm::DatabaseConnection;

<span class="kw">mod</span> dto;
<span class="kw">mod</span> handlers;
<span class="kw">mod</span> models;
<span class="kw">mod</span> routes;
<span class="kw">mod</span> services;

<span class="kw">pub struct</span> <span class="type">BlogModule</span>;

<span class="kw">impl</span> <span class="type">BlogModule</span> {
    <span class="kw">pub fn</span> <span class="fn">new</span>() -> <span class="type">Self</span> { <span class="type">Self</span> }
}

<span class="attr">#[async_trait]</span>
<span class="kw">impl</span> ChopinModule <span class="kw">for</span> <span class="type">BlogModule</span> {
    <span class="kw">fn</span> <span class="fn">name</span>(&self) -> &<span class="type">str</span> { <span class="str">"blog"</span> }
    <span class="kw">fn</span> <span class="fn">routes</span>(&self) -> Router&lt;AppState&gt; { routes::routes() }
    <span class="kw">async fn</span> <span class="fn">migrate</span>(&self, _db: &DatabaseConnection) -> <span class="type">Result</span>&lt;(), ChopinError&gt; { <span class="type">Ok</span>(()) }
}</code></pre>

                <h3>Mount modules in main.rs</h3>
<pre><code><span class="kw">use</span> chopin_core::prelude::*;
<span class="kw">mod</span> apps;

<span class="attr">#[tokio::main]</span>
<span class="kw">async fn</span> <span class="fn">main</span>() -> <span class="type">Result</span>&lt;(), Box&lt;<span class="kw">dyn</span> std::error::Error&gt;&gt; {
    init_logging();

    <span class="kw">let</span> app = App::new().<span class="kw">await</span>?;
    <span class="kw">let</span> app = app.mount_module(apps::blog::BlogModule::new());
    <span class="comment">// .mount_module(apps::billing::BillingModule::new())</span>
    <span class="comment">// .mount_module(apps::inventory::InventoryModule::new())</span>

    app.run().<span class="kw">await</span>?;
    <span class="type">Ok</span>(())
}</code></pre>

                <div class="tip">
                    <strong>Tip:</strong> <code>chopin startapp</code> auto-registers the module in <code>src/apps/mod.rs</code> and auto-mounts it in <code>src/main.rs</code> — no manual wiring needed!
                </div>
            </section>

            <!-- 2. Authentication -->
            <section id="authentication" class="tutorial-section">
                <div class="section-number">08</div>
                <h2>Authentication</h2>
                <p>Chopin provides <strong>built-in JWT authentication</strong> with Argon2id password hashing. The <code>/api/auth/signup</code> and <code>/api/auth/login</code> endpoints are included automatically.</p>

                <h3>Sign up a user</h3>
<pre><code>curl -X POST http://localhost:3000/api/auth/signup \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "password": "securepassword123",
    "name": "John Doe"
  }'

<span class="comment"># Response:</span>
<span class="comment"># {</span>
<span class="comment">#   "success": true,</span>
<span class="comment">#   "data": {</span>
<span class="comment">#     "token": "eyJhbGciOiJIUzI1...",</span>
<span class="comment">#     "user": { "id": "uuid", "email": "user@example.com", "name": "John Doe", "role": "user" }</span>
<span class="comment">#   }</span>
<span class="comment"># }</span></code></pre>

                <h3>Log in</h3>
<pre><code>curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "password": "securepassword123"
  }'</code></pre>

                <h3>How it works internally</h3>
<pre><code><span class="comment">// Passwords are hashed with Argon2id (memory-hard, GPU-resistant)</span>
<span class="kw">use</span> chopin_core::auth::password;

<span class="kw">let</span> hash = password::hash_password(<span class="str">"my-password"</span>)?;
<span class="kw">let</span> valid = password::verify_password(<span class="str">"my-password"</span>, &hash)?;

<span class="comment">// JWTs are signed with HS256</span>
<span class="kw">use</span> chopin_core::auth::jwt;

<span class="kw">let</span> token = jwt::create_token(
    &user_id,             <span class="comment">// UUID string</span>
    &email,
    &role,                <span class="comment">// "user", "admin", "superuser"</span>
    &config.jwt_secret,
    config.jwt_expiry_hours,
)?;

<span class="kw">let</span> claims = jwt::validate_token(&token, &config.jwt_secret)?;
<span class="comment">// claims.sub = user_id, claims.email, claims.role</span></code></pre>
            </section>

            <!-- 3. Security Features -->
            <section id="security" class="tutorial-section">
                <div class="section-number">08b</div>
                <h2>Security Features</h2>
                <p>Chopin includes <strong>9 production security features</strong>, all <strong>enabled by default</strong>. No extra code or config needed — just deploy. Each feature can be individually disabled via environment variables.</p>

                <h3>Overview</h3>
                <table class="config-table">
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>What It Does</th>
                            <th>Env Var to Disable</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td><strong>2FA/TOTP</strong></td><td>Time-based One-Time Password</td><td><code>SECURITY_2FA=false</code></td></tr>
                        <tr><td><strong>Rate Limiting</strong></td><td>Blocks login after 5 attempts per 5 min</td><td><code>SECURITY_RATE_LIMIT=false</code></td></tr>
                        <tr><td><strong>Account Lockout</strong></td><td>Locks account after 5 failed attempts</td><td><code>SECURITY_ACCOUNT_LOCKOUT=false</code></td></tr>
                        <tr><td><strong>Refresh Tokens</strong></td><td>Automatic rotation with reuse detection</td><td><code>SECURITY_REFRESH_TOKENS=false</code></td></tr>
                        <tr><td><strong>Session Management</strong></td><td>Server-side sessions, revoke one or all</td><td><code>SECURITY_SESSION_MANAGEMENT=false</code></td></tr>
                        <tr><td><strong>Password Reset</strong></td><td>Secure token-based password reset</td><td><code>SECURITY_PASSWORD_RESET=false</code></td></tr>
                        <tr><td><strong>Email Verification</strong></td><td>Require email verification on signup</td><td><code>SECURITY_EMAIL_VERIFICATION=false</code></td></tr>
                        <tr><td><strong>CSRF Protection</strong></td><td>Token verified on state-changing requests</td><td><code>SECURITY_CSRF=false</code></td></tr>
                        <tr><td><strong>IP/Device Tracking</strong></td><td>Audit log of all login events</td><td><code>SECURITY_DEVICE_TRACKING=false</code></td></tr>
                    </tbody>
                </table>

                <h3>2FA / TOTP Setup Flow</h3>
<pre><code><span class="comment"># 1. Setup — get the TOTP secret and QR code URI</span>
curl -X POST http://localhost:3000/api/auth/totp/setup \
  -H "Authorization: Bearer &lt;token&gt;"

<span class="comment"># 2. User scans QR code in Google Authenticator / Authy</span>
<span class="comment"># 3. Verify and enable with a code from the app:</span>
curl -X POST http://localhost:3000/api/auth/totp/enable \
  -H "Authorization: Bearer &lt;token&gt;" \
  -H "Content-Type: application/json" \
  -d '{ "code": "123456" }'

<span class="comment"># Future logins now require the totp_code field:</span>
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{ "email": "user@example.com", "password": "pw", "totp_code": "654321" }'</code></pre>

                <h3>Logout & Session Revocation</h3>
<pre><code><span class="comment"># Logout current session</span>
curl -X POST http://localhost:3000/api/auth/logout \
  -H "Authorization: Bearer &lt;token&gt;" \
  -H "Content-Type: application/json" \
  -d '{ "all_sessions": false }'

<span class="comment"># Logout everywhere (revoke ALL sessions)</span>
curl -X POST http://localhost:3000/api/auth/logout \
  -H "Authorization: Bearer &lt;token&gt;" \
  -H "Content-Type: application/json" \
  -d '{ "all_sessions": true }'</code></pre>
            </section>

            <!-- 4. Roles & Permissions -->
            <section id="roles" class="tutorial-section">
                <div class="section-number">09</div>
                <h2>Roles & Permissions</h2>
                <p>Chopin has a simple but effective <strong>hierarchical role system</strong>. Higher roles inherit all permissions of lower roles.</p>

                <div class="role-hierarchy">
                    <div class="role-card">
                        <div class="role-level">Level 0</div>
                        <h4>User</h4>
                        <p>Default role for new accounts</p>
                    </div>
                    <div class="role-arrow">&rarr;</div>
                    <div class="role-card">
                        <div class="role-level">Level 1</div>
                        <h4>Admin</h4>
                        <p>Can do everything User can + admin actions</p>
                    </div>
                    <div class="role-arrow">&rarr;</div>
                    <div class="role-card">
                        <div class="role-level">Level 2</div>
                        <h4>Superuser</h4>
                        <p>Full access to everything</p>
                    </div>
                </div>

                <h3>Protect routes by role</h3>
<pre><code><span class="kw">use</span> chopin_core::extractors::AuthUserWithRole;
<span class="kw">use</span> chopin_core::models::user::Role;

<span class="comment">// Only admins and superusers can access this</span>
<span class="kw">pub async fn</span> <span class="fn">admin_dashboard</span>(
    user: AuthUserWithRole&lt;{ Role::Admin <span class="kw">as</span> u8 }&gt;,
) -> <span class="kw">impl</span> IntoResponse {
    <span class="comment">// user.user_id, user.email, user.role are available</span>
    chopin_core::Json(json!({ "message": "Welcome, admin!" }))
}

<span class="comment">// Or use the require_role middleware on a group of routes</span>
<span class="kw">use</span> chopin_core::extractors::require_role;

<span class="kw">fn</span> <span class="fn">admin_routes</span>() -> Router&lt;AppState&gt; {
    Router::new()
        .route(<span class="str">"/api/admin/users"</span>, get(list_users))
        .route(<span class="str">"/api/admin/stats"</span>, get(admin_stats))
        .layer(chopin_core::middleware::from_fn(require_role::&lt;{ Role::Admin <span class="kw">as</span> u8 }&gt;))
}</code></pre>

                <h3>Create a superuser</h3>
<pre><code><span class="comment"># Via CLI</span>
chopin createsuperuser</code></pre>
            </section>

            <!-- 5. Extractors -->
            <section id="extractors" class="tutorial-section">
                <div class="section-number">10</div>
                <h2>Extractors</h2>
                <p>Extractors are Axum's way of parsing request data. Chopin provides custom extractors for common patterns.</p>

                <h3>AuthUser — JWT authentication</h3>
<pre><code><span class="kw">use</span> chopin_core::extractors::AuthUser;

<span class="comment">// Automatically validates the Bearer token from Authorization header</span>
<span class="kw">pub async fn</span> <span class="fn">get_profile</span>(user: AuthUser) -> <span class="kw">impl</span> IntoResponse {
    <span class="comment">// user.user_id: String (UUID)</span>
    <span class="comment">// user.email: String</span>
    <span class="comment">// user.role: String</span>
    chopin_core::Json(json!({
        "id": user.user_id,
        "email": user.email,
        "role": user.role,
    }))
}</code></pre>

                <h3>Json — SIMD-accelerated body parsing</h3>
<pre><code><span class="kw">use</span> chopin_core::extractors::Json;

<span class="comment">// When `perf` feature is enabled, uses sonic-rs (SIMD)</span>
<span class="comment">// Otherwise falls back to serde_json</span>
<span class="kw">pub async fn</span> <span class="fn">create_item</span>(
    Json(payload): Json&lt;CreateItemRequest&gt;,
) -> <span class="kw">impl</span> IntoResponse {
    <span class="comment">// payload is deserialized from request body</span>
}</code></pre>

                <h3>Pagination — query parameter extraction</h3>
<pre><code><span class="kw">use</span> chopin_core::extractors::Pagination;

<span class="comment">// GET /api/posts?page=2&per_page=20</span>
<span class="kw">pub async fn</span> <span class="fn">list_items</span>(
    Query(pagination): Query&lt;Pagination&gt;,
) {
    <span class="kw">let</span> p = pagination.clamped(); <span class="comment">// Enforces min/max</span>
    <span class="comment">// p.page: clamped to 1..10000</span>
    <span class="comment">// p.per_page: clamped to 1..100</span>
    <span class="comment">// p.offset: computed as (page - 1) * per_page</span>
    <span class="comment">// p.limit: same as per_page</span>
}</code></pre>
            </section>

            <!-- 6. Pagination -->
            <section id="pagination" class="tutorial-section">
                <div class="section-number">11</div>
                <h2>Pagination</h2>
                <p>Chopin provides a complete pagination system with clamped values and a standardized response format.</p>

<pre><code><span class="kw">use</span> chopin_core::extractors::{Pagination, PaginatedResponse};

<span class="kw">pub async fn</span> <span class="fn">list_posts</span>(
    State(state): State&lt;AppState&gt;,
    Query(pagination): Query&lt;Pagination&gt;,
) -> chopin_core::Json&lt;PaginatedResponse&lt;PostResponse&gt;&gt; {
    <span class="kw">let</span> p = pagination.clamped();

    <span class="comment">// Count total items</span>
    <span class="kw">let</span> total = Post::find().count(&state.db).<span class="kw">await</span>.unwrap_or(<span class="num">0</span>);

    <span class="comment">// Fetch page</span>
    <span class="kw">let</span> items = Post::find()
        .offset(p.offset)
        .limit(p.limit)
        .all(&state.db).<span class="kw">await</span>.unwrap_or_default()
        .into_iter().map(PostResponse::from).collect();

    chopin_core::Json(PaginatedResponse::new(items, total, p.page, p.per_page))
}</code></pre>

                <p>Response format:</p>
<pre><code><span class="comment">// {</span>
<span class="comment">//   "data": [...],</span>
<span class="comment">//   "pagination": {</span>
<span class="comment">//     "page": 1,</span>
<span class="comment">//     "per_page": 20,</span>
<span class="comment">//     "total": 150,</span>
<span class="comment">//     "total_pages": 8</span>
<span class="comment">//   }</span>
<span class="comment">// }</span></code></pre>
            </section>

            <!-- 7. Error Handling -->
            <section id="error-handling" class="tutorial-section">
                <div class="section-number">12</div>
                <h2>Error Handling</h2>
                <p>Chopin provides a unified error type that automatically maps to HTTP status codes and JSON responses.</p>

<pre><code><span class="kw">use</span> chopin_core::error::{ChopinError, FieldError};

<span class="comment">// Each variant maps to an HTTP status code</span>
ChopinError::NotFound(<span class="str">"User not found"</span>.into())         <span class="comment">// 404</span>
ChopinError::BadRequest(<span class="str">"Invalid input"</span>.into())         <span class="comment">// 400</span>
ChopinError::Unauthorized(<span class="str">"Invalid token"</span>.into())       <span class="comment">// 401</span>
ChopinError::Forbidden(<span class="str">"Not allowed"</span>.into())            <span class="comment">// 403</span>
ChopinError::Conflict(<span class="str">"Email already exists"</span>.into())   <span class="comment">// 409</span>
ChopinError::Internal(<span class="str">"Something broke"</span>.into())        <span class="comment">// 500</span>

<span class="comment">// All errors produce consistent JSON:</span>
<span class="comment">// { "success": false, "error": "User not found" }</span></code></pre>

                <h3>Field-level validation errors</h3>
<pre><code><span class="comment">// Return multiple field errors at once</span>
<span class="kw">let</span> errors = <span class="kw">vec!</span>[
    FieldError::new(<span class="str">"email"</span>, <span class="str">"must be a valid email address"</span>),
    FieldError::new(<span class="str">"password"</span>, <span class="str">"must be at least 8 characters"</span>),
];
<span class="kw">return</span> Err(ChopinError::ValidationErrors(errors));

<span class="comment">// Response (422):</span>
<span class="comment">// {</span>
<span class="comment">//   "success": false,</span>
<span class="comment">//   "error": "Validation failed",</span>
<span class="comment">//   "fields": [</span>
<span class="comment">//     { "field": "email", "message": "must be a valid email address" },</span>
<span class="comment">//     { "field": "password", "message": "must be at least 8 characters" }</span>
<span class="comment">//   ]</span>
<span class="comment">// }</span></code></pre>

                <h3>Using in handlers</h3>
<pre><code><span class="kw">use</span> chopin_core::error::ChopinError;
<span class="kw">use</span> chopin_core::response::ApiResponse;

<span class="kw">pub async fn</span> <span class="fn">get_post</span>(
    State(state): State&lt;AppState&gt;,
    Path(id): Path&lt;<span class="type">i32</span>&gt;,
) -> <span class="type">Result</span>&lt;chopin_core::Json&lt;ApiResponse&lt;PostResponse&gt;&gt;, ChopinError&gt; {
    <span class="kw">let</span> post = Post::find_by_id(id)
        .one(&state.db).<span class="kw">await</span>
        .map_err(|e| ChopinError::Database(e.to_string()))?
        .ok_or_else(|| ChopinError::NotFound(<span class="kw">format!</span>(<span class="str">"Post {} not found"</span>, id)))?;

    <span class="type">Ok</span>(chopin_core::Json(ApiResponse::success(PostResponse::from(post))))
}</code></pre>
            </section>

            <!-- Navigation -->
            <nav class="tutorial-nav">
                <a href="tutorial-database.html" class="btn-secondary">&larr; Database</a>
                <a href="tutorial-advanced.html" class="btn-primary">Next: Advanced →</a>
            </nav>

        </main>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-bottom" style="border-top: none; padding-top: 0;">
                <div class="footer-bottom-left">
                    <p>&copy; 2026 Chopin. All rights reserved.</p>
                </div>
                <div class="footer-bottom-right">
                    <p>Made with <i data-lucide="music" class="inline-icon-sm"></i> by the <a href="https://github.com/kowito">Chopin team</a></p>
                </div>
            </div>
        </div>
    </footer>

    <script src="js/main.js"></script>
    <script>
        lucide.createIcons();

        const sections = document.querySelectorAll('.tutorial-section');
        const tocLinks = document.querySelectorAll('.toc-link');

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    tocLinks.forEach(link => link.classList.remove('active'));
                    const id = entry.target.getAttribute('id');
                    const activeLink = document.querySelector(`.toc-link[href="#${id}"]`);
                    if (activeLink) activeLink.classList.add('active');
                }
            });
        }, { rootMargin: '-80px 0px -60% 0px' });

        sections.forEach(section => observer.observe(section));
    </script>
</body>
</html>
