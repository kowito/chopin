<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Chopin Tutorial - Complete guide to building production-ready APIs with the fastest Rust web framework.">
    <title>Tutorial - Chopin Framework</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/tutorial.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&family=Caveat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
</head>
<body>
    <!-- Navigation -->
    <nav class="nav">
        <div class="container">
            <div class="nav-content">
                <div class="nav-logo">
                    <a href="index.html" style="display:flex;align-items:center;gap:0.75rem;text-decoration:none;color:inherit;">
                        <i data-lucide="music" class="logo-icon"></i>
                        <span class="logo-text">Chopin</span>
                    </a>
                </div>
                <div class="nav-links">
                    <a href="index.html#features">Features</a>
                    <a href="index.html#benchmarks">Benchmarks</a>
                    <a href="tutorial.html" class="active">Tutorial</a>
                    <a href="https://docs.rs/chopin">API Docs</a>
                    <a href="https://github.com/kowito/chopin" class="btn-primary">GitHub</a>
                </div>
            </div>
        </div>
    </nav>

    <div class="tutorial-layout">
        <!-- Sidebar TOC -->
        <aside class="tutorial-sidebar">
            <div class="toc">
                <h3 class="toc-title">Tutorial</h3>
                <ol class="toc-list">
                    <li><a href="#installation" class="toc-link">Installation</a></li>
                    <li><a href="#hello-world" class="toc-link">Hello World</a></li>
                    <li><a href="#configuration" class="toc-link">Configuration</a></li>
                    <li><a href="#database" class="toc-link">Database & Models</a></li>
                    <li><a href="#migrations" class="toc-link">Migrations</a></li>
                    <li><a href="#controllers" class="toc-link">Controllers & Routing</a></li>
                    <li><a href="#authentication" class="toc-link">Authentication</a></li>
                    <li><a href="#roles" class="toc-link">Roles & Permissions</a></li>
                    <li><a href="#extractors" class="toc-link">Extractors</a></li>
                    <li><a href="#pagination" class="toc-link">Pagination</a></li>
                    <li><a href="#error-handling" class="toc-link">Error Handling</a></li>
                    <li><a href="#openapi" class="toc-link">OpenAPI Docs</a></li>
                    <li><a href="#caching" class="toc-link">Caching</a></li>
                    <li><a href="#file-uploads" class="toc-link">File Uploads</a></li>
                    <li><a href="#graphql" class="toc-link">GraphQL</a></li>
                    <li><a href="#testing" class="toc-link">Testing</a></li>
                    <li><a href="#performance" class="toc-link">Performance</a></li>
                    <li><a href="#production" class="toc-link">Production Deployment</a></li>
                </ol>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="tutorial-content">

            <!-- Hero -->
            <div class="tutorial-hero">
                <h1>From Zero to Production</h1>
                <p>A complete guide to building high-performance APIs with Chopin. Every feature, every pattern, from your first line of code to production deployment.</p>
            </div>

            <!-- 1. Installation -->
            <section id="installation" class="tutorial-section">
                <div class="section-number">01</div>
                <h2>Installation</h2>
                <p>Chopin requires <strong>Rust 1.75+</strong>. Install the CLI tool and scaffold your first project in seconds.</p>

                <h3>Install the CLI</h3>
<pre><code><span class="comment"># Install Chopin CLI from crates.io</span>
cargo install chopin-cli</code></pre>

                <h3>Create a new project</h3>
<pre><code><span class="comment"># Scaffold a new Chopin project</span>
chopin new my-api
<span class="kw">cd</span> my-api

<span class="comment"># Your project structure:</span>
<span class="comment"># my-api/</span>
<span class="comment">#   Cargo.toml</span>
<span class="comment">#   .env</span>
<span class="comment">#   src/</span>
<span class="comment">#     main.rs</span>
<span class="comment">#     lib.rs</span>
<span class="comment">#     controllers/</span>
<span class="comment">#     models/</span>
<span class="comment">#     migrations/</span></code></pre>

                <h3>Or add to an existing project</h3>
<pre><code><span class="comment"># Add chopin as a dependency</span>
cargo add chopin

<span class="comment"># With optional features</span>
cargo add chopin --features redis,s3,graphql,perf</code></pre>

                <div class="callout">
                    <i data-lucide="info" class="inline-icon"></i>
                    <div>
                        <strong>Feature flags:</strong>
                        <code>redis</code> &mdash; Redis caching backend,
                        <code>s3</code> &mdash; S3/R2/MinIO file storage,
                        <code>graphql</code> &mdash; GraphQL support,
                        <code>perf</code> &mdash; mimalloc + sonic-rs SIMD JSON
                    </div>
                </div>
            </section>

            <!-- 2. Hello World -->
            <section id="hello-world" class="tutorial-section">
                <div class="section-number">02</div>
                <h2>Hello World</h2>
                <p>The simplest Chopin app is <strong>4 lines of code</strong>. It gives you a running server with auth endpoints, database, and OpenAPI docs out of the box.</p>

<pre><code><span class="kw">use</span> chopin::App;

<span class="attr">#[tokio::main]</span>
<span class="kw">async fn</span> <span class="fn">main</span>() -> <span class="type">Result</span>&lt;(), Box&lt;<span class="kw">dyn</span> std::error::Error&gt;&gt; {
    tracing_subscriber::fmt::init();

    <span class="kw">let</span> app = App::new().<span class="kw">await</span>?;
    app.run().<span class="kw">await</span>?;

    <span class="type">Ok</span>(())
}</code></pre>

<pre><code><span class="comment"># Run it</span>
cargo run

<span class="comment"># Output:</span>
<span class="comment"># ðŸŽ¹ Chopin is running</span>
<span class="comment">#    â†’ Server:    http://127.0.0.1:3000</span>
<span class="comment">#    â†’ API docs:  http://127.0.0.1:3000/api-docs</span>
<span class="comment">#    â†’ Mode:      standard</span></code></pre>

                <p>You already have these endpoints:</p>
                <div class="endpoint-table">
                    <table>
                        <thead>
                            <tr><th>Method</th><th>Path</th><th>Description</th></tr>
                        </thead>
                        <tbody>
                            <tr><td><span class="method get">GET</span></td><td><code>/</code></td><td>Welcome JSON</td></tr>
                            <tr><td><span class="method post">POST</span></td><td><code>/api/auth/signup</code></td><td>Create a user account</td></tr>
                            <tr><td><span class="method post">POST</span></td><td><code>/api/auth/login</code></td><td>Login &amp; get JWT token</td></tr>
                            <tr><td><span class="method get">GET</span></td><td><code>/api-docs</code></td><td>Scalar OpenAPI UI</td></tr>
                            <tr><td><span class="method get">GET</span></td><td><code>/api-docs/openapi.json</code></td><td>Raw OpenAPI spec</td></tr>
                        </tbody>
                    </table>
                </div>
            </section>

            <!-- 3. Configuration -->
            <section id="configuration" class="tutorial-section">
                <div class="section-number">03</div>
                <h2>Configuration</h2>
                <p>Chopin loads configuration from environment variables via a <code>.env</code> file. Every setting has a sensible default.</p>

<pre><code><span class="comment"># .env â€” Chopin configuration</span>

<span class="comment"># Server</span>
REUSEPORT=false               <span class="comment"># true for multi-core SO_REUSEPORT</span>
SERVER_HOST=127.0.0.1
SERVER_PORT=3000
ENVIRONMENT=development       <span class="comment"># development | production</span>

<span class="comment"># Database (SeaORM â€” supports SQLite, PostgreSQL, MySQL)</span>
DATABASE_URL=sqlite://chopin.db?mode=rwc

<span class="comment"># Authentication</span>
JWT_SECRET=change-me-in-production
JWT_EXPIRY_HOURS=24

<span class="comment"># Redis (requires `redis` feature)</span>
REDIS_URL=redis://127.0.0.1:6379

<span class="comment"># File Uploads</span>
UPLOAD_DIR=./uploads
MAX_UPLOAD_SIZE=10485760      <span class="comment"># 10MB in bytes</span>

<span class="comment"># S3 Storage (requires `s3` feature)</span>
S3_BUCKET=my-bucket
S3_REGION=us-east-1
S3_ENDPOINT=                  <span class="comment"># For R2/MinIO</span>
S3_ACCESS_KEY=
S3_SECRET_KEY=
S3_PUBLIC_URL=                <span class="comment"># CDN or public URL prefix</span>
S3_PREFIX=uploads             <span class="comment"># Object key prefix</span></code></pre>

                <p>Access config in your code:</p>
<pre><code><span class="kw">use</span> chopin::config::Config;

<span class="kw">let</span> config = Config::from_env()?;

<span class="comment">// Useful helpers</span>
config.is_dev()       <span class="comment">// true if ENVIRONMENT=development</span>
config.has_s3()       <span class="comment">// true if S3_BUCKET is set</span>
config.server_addr()  <span class="comment">// "127.0.0.1:3000"</span></code></pre>

                <h3>Custom config with App</h3>
<pre><code><span class="comment">// Override config programmatically</span>
<span class="kw">let mut</span> config = Config::from_env()?;
config.server_port = <span class="num">8080</span>;

<span class="kw">let</span> app = App::with_config(config).<span class="kw">await</span>?;
app.run().<span class="kw">await</span>?;</code></pre>
            </section>

            <!-- 4. Database & Models -->
            <section id="database" class="tutorial-section">
                <div class="section-number">04</div>
                <h2>Database & Models</h2>
                <p>Chopin uses <strong>SeaORM</strong> for database access. It supports SQLite, PostgreSQL, and MySQL with the same code. Models are defined as Rust structs with derive macros.</p>

                <h3>Connection</h3>
                <p>Chopin connects automatically when you call <code>App::new()</code>. To connect manually:</p>
<pre><code><span class="kw">use</span> chopin::{config::Config, db};

<span class="kw">let</span> config = Config::from_env()?;
<span class="kw">let</span> conn = db::connect(&config).<span class="kw">await</span>?;

<span class="comment">// Connection pool is pre-configured:</span>
<span class="comment">// max_connections: 100, min_connections: 5</span>
<span class="comment">// connect_timeout: 8s, idle_timeout: 8s</span></code></pre>

                <h3>Defining a model</h3>
                <p>Use the CLI to scaffold, or define manually:</p>
<pre><code><span class="comment"># Generate model + migration + controller</span>
chopin generate model Post title:string body:text published:bool</code></pre>

<pre><code><span class="comment">// src/models/post.rs</span>
<span class="kw">use</span> chrono::NaiveDateTime;
<span class="kw">use</span> sea_orm::entity::prelude::*;
<span class="kw">use</span> serde::{Deserialize, Serialize};
<span class="kw">use</span> utoipa::ToSchema;

<span class="attr">#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel, Serialize, Deserialize)]</span>
<span class="attr">#[sea_orm(table_name = "posts")]</span>
<span class="kw">pub struct</span> <span class="type">Model</span> {
    <span class="attr">#[sea_orm(primary_key)]</span>
    <span class="kw">pub</span> id: <span class="type">i32</span>,
    <span class="kw">pub</span> title: <span class="type">String</span>,
    <span class="attr">#[sea_orm(column_type = "Text")]</span>
    <span class="kw">pub</span> body: <span class="type">String</span>,
    <span class="attr">#[sea_orm(default_value = "false")]</span>
    <span class="kw">pub</span> published: <span class="type">bool</span>,
    <span class="kw">pub</span> created_at: <span class="type">NaiveDateTime</span>,
    <span class="kw">pub</span> updated_at: <span class="type">NaiveDateTime</span>,
}

<span class="attr">#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]</span>
<span class="kw">pub enum</span> <span class="type">Relation</span> {}

<span class="kw">impl</span> ActiveModelBehavior <span class="kw">for</span> ActiveModel {}

<span class="comment">// Response DTO â€” what clients see</span>
<span class="attr">#[derive(Debug, Serialize, Deserialize, ToSchema)]</span>
<span class="kw">pub struct</span> <span class="type">PostResponse</span> {
    <span class="kw">pub</span> id: <span class="type">i32</span>,
    <span class="kw">pub</span> title: <span class="type">String</span>,
    <span class="kw">pub</span> body: <span class="type">String</span>,
    <span class="kw">pub</span> published: <span class="type">bool</span>,
    <span class="kw">pub</span> created_at: <span class="type">String</span>,
    <span class="kw">pub</span> updated_at: <span class="type">String</span>,
}

<span class="kw">impl</span> From&lt;Model&gt; <span class="kw">for</span> <span class="type">PostResponse</span> {
    <span class="kw">fn</span> <span class="fn">from</span>(m: Model) -> <span class="type">Self</span> {
        <span class="type">PostResponse</span> {
            id: m.id,
            title: m.title,
            body: m.body,
            published: m.published,
            created_at: m.created_at.format(<span class="str">"%Y-%m-%dT%H:%M:%S"</span>).to_string(),
            updated_at: m.updated_at.format(<span class="str">"%Y-%m-%dT%H:%M:%S"</span>).to_string(),
        }
    }
}</code></pre>

                <h3>CRUD operations</h3>
<pre><code><span class="kw">use</span> sea_orm::*;
<span class="kw">use</span> crate::models::post::{self, Entity <span class="kw">as</span> Post};

<span class="comment">// Create</span>
<span class="kw">let</span> new = post::ActiveModel {
    title: Set(<span class="str">"Hello"</span>.into()),
    body: Set(<span class="str">"World"</span>.into()),
    ..Default::default()
};
<span class="kw">let</span> result = new.insert(&db).<span class="kw">await</span>?;

<span class="comment">// Read</span>
<span class="kw">let</span> post = Post::find_by_id(<span class="num">1</span>).one(&db).<span class="kw">await</span>?;
<span class="kw">let</span> all = Post::find().all(&db).<span class="kw">await</span>?;

<span class="comment">// Update</span>
<span class="kw">let mut</span> active: post::ActiveModel = post.unwrap().into();
active.title = Set(<span class="str">"Updated"</span>.into());
<span class="kw">let</span> updated = active.update(&db).<span class="kw">await</span>?;

<span class="comment">// Delete</span>
Post::delete_by_id(<span class="num">1</span>).exec(&db).<span class="kw">await</span>?;</code></pre>
            </section>

            <!-- 5. Migrations -->
            <section id="migrations" class="tutorial-section">
                <div class="section-number">05</div>
                <h2>Migrations</h2>
                <p>Migrations run <strong>automatically on startup</strong>. Chopin uses SeaORM's migration system &mdash; define them as Rust code, and they're applied when the app boots.</p>

<pre><code><span class="comment">// src/migrations/m20250101_000001_create_posts_table.rs</span>
<span class="kw">use</span> sea_orm_migration::{prelude::*, schema::*};

<span class="attr">#[derive(DeriveMigrationName)]</span>
<span class="kw">pub struct</span> <span class="type">Migration</span>;

<span class="attr">#[async_trait::async_trait]</span>
<span class="kw">impl</span> MigrationTrait <span class="kw">for</span> <span class="type">Migration</span> {
    <span class="kw">async fn</span> <span class="fn">up</span>(&self, manager: &SchemaManager) -> <span class="type">Result</span>&lt;(), DbErr&gt; {
        manager
            .create_table(
                Table::create()
                    .table(Posts::Table)
                    .if_not_exists()
                    .col(pk_auto(Posts::Id))
                    .col(string(Posts::Title))
                    .col(text(Posts::Body))
                    .col(boolean(Posts::Published).default(<span class="kw">false</span>))
                    .col(timestamp(Posts::CreatedAt))
                    .col(timestamp(Posts::UpdatedAt))
                    .to_owned(),
            )
            .<span class="kw">await</span>
    }

    <span class="kw">async fn</span> <span class="fn">down</span>(&self, manager: &SchemaManager) -> <span class="type">Result</span>&lt;(), DbErr&gt; {
        manager
            .drop_table(Table::drop().table(Posts::Table).to_owned())
            .<span class="kw">await</span>
    }
}

<span class="attr">#[derive(DeriveIden)]</span>
<span class="kw">enum</span> <span class="type">Posts</span> {
    Table, Id, Title, Body, Published, CreatedAt, UpdatedAt,
}</code></pre>

                <h3>Register migrations</h3>
<pre><code><span class="comment">// src/migrations/mod.rs</span>
<span class="kw">pub use</span> sea_orm_migration::prelude::*;

<span class="kw">mod</span> m20250101_000001_create_posts_table;

<span class="kw">pub struct</span> <span class="type">Migrator</span>;

<span class="attr">#[async_trait::async_trait]</span>
<span class="kw">impl</span> MigratorTrait <span class="kw">for</span> <span class="type">Migrator</span> {
    <span class="kw">fn</span> <span class="fn">migrations</span>() -> Vec&lt;Box&lt;<span class="kw">dyn</span> MigrationTrait&gt;&gt; {
        <span class="kw">vec!</span>[Box::new(m20250101_000001_create_posts_table::Migration)]
    }
}</code></pre>

                <h3>CLI migration commands</h3>
<pre><code><span class="comment"># Run pending migrations</span>
chopin db migrate

<span class="comment"># Rollback last migration</span>
chopin db rollback

<span class="comment"># Rollback N migrations</span>
chopin db rollback --steps 3

<span class="comment"># Show migration status</span>
chopin db status

<span class="comment"># Reset database (rollback all + migrate)</span>
chopin db reset</code></pre>
            </section>

            <!-- 6. Controllers & Routing -->
            <section id="controllers" class="tutorial-section">
                <div class="section-number">06</div>
                <h2>Controllers & Routing</h2>
                <p>Controllers are Axum handlers grouped into modules. Chopin follows the standard Axum routing pattern with shared application state.</p>

                <h3>Application state</h3>
<pre><code><span class="comment">// Chopin provides this built-in:</span>
<span class="attr">#[derive(Clone)]</span>
<span class="kw">pub struct</span> <span class="type">AppState</span> {
    <span class="kw">pub</span> db: DatabaseConnection,
    <span class="kw">pub</span> config: Config,
    <span class="kw">pub</span> cache: Option&lt;CacheService&gt;,
}</code></pre>

                <h3>Defining routes</h3>
<pre><code><span class="comment">// src/controllers/posts.rs</span>
<span class="kw">use</span> axum::{extract::{Path, Query, State}, routing::get, Router};
<span class="kw">use</span> chopin::response::ApiResponse;
<span class="kw">use</span> crate::AppState;

<span class="kw">pub fn</span> <span class="fn">routes</span>() -> Router&lt;AppState&gt; {
    Router::new()
        .route(<span class="str">"/api/posts"</span>, get(list_posts).post(create_post))
        .route(<span class="str">"/api/posts/{id}"</span>, get(get_post).put(update_post).delete(delete_post))
}

<span class="kw">pub async fn</span> <span class="fn">list_posts</span>(
    State(state): State&lt;AppState&gt;,
    Query(pagination): Query&lt;Pagination&gt;,
) -> <span class="type">Result</span>&lt;axum::Json&lt;ApiResponse&lt;Vec&lt;PostResponse&gt;&gt;&gt;, StatusCode&gt; {
    <span class="kw">let</span> posts = Post::find()
        .order_by_desc(post::Column::CreatedAt)
        .offset(pagination.clamped().offset)
        .limit(pagination.clamped().limit)
        .all(&state.db).<span class="kw">await</span>
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    <span class="type">Ok</span>(axum::Json(ApiResponse::success(
        posts.into_iter().map(PostResponse::from).collect()
    )))
}

<span class="kw">pub async fn</span> <span class="fn">create_post</span>(
    State(state): State&lt;AppState&gt;,
    axum::Json(payload): axum::Json&lt;CreatePostRequest&gt;,
) -> <span class="type">Result</span>&lt;(StatusCode, axum::Json&lt;ApiResponse&lt;PostResponse&gt;&gt;), StatusCode&gt; {
    <span class="kw">let</span> new = post::ActiveModel {
        title: Set(payload.title),
        body: Set(payload.body),
        ..Default::default()
    };
    <span class="kw">let</span> result = new.insert(&state.db).<span class="kw">await</span>
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    <span class="type">Ok</span>((StatusCode::CREATED, axum::Json(ApiResponse::success(PostResponse::from(result)))))
}</code></pre>

                <h3>Generate a controller</h3>
<pre><code><span class="comment"># Scaffold CRUD controller</span>
chopin generate controller posts</code></pre>
            </section>

            <!-- 7. Authentication -->
            <section id="authentication" class="tutorial-section">
                <div class="section-number">07</div>
                <h2>Authentication</h2>
                <p>Chopin provides <strong>built-in JWT authentication</strong> with Argon2id password hashing. The <code>/api/auth/signup</code> and <code>/api/auth/login</code> endpoints are included automatically.</p>

                <h3>Sign up a user</h3>
<pre><code>curl -X POST http://localhost:3000/api/auth/signup \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "password": "securepassword123",
    "name": "John Doe"
  }'

<span class="comment"># Response:</span>
<span class="comment"># {</span>
<span class="comment">#   "success": true,</span>
<span class="comment">#   "data": {</span>
<span class="comment">#     "token": "eyJhbGciOiJIUzI1...",</span>
<span class="comment">#     "user": { "id": "uuid", "email": "user@example.com", "name": "John Doe", "role": "user" }</span>
<span class="comment">#   }</span>
<span class="comment"># }</span></code></pre>

                <h3>Log in</h3>
<pre><code>curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "password": "securepassword123"
  }'</code></pre>

                <h3>How it works internally</h3>
<pre><code><span class="comment">// Passwords are hashed with Argon2id (memory-hard, GPU-resistant)</span>
<span class="kw">use</span> chopin::auth::password;

<span class="kw">let</span> hash = password::hash_password(<span class="str">"my-password"</span>)?;
<span class="kw">let</span> valid = password::verify_password(<span class="str">"my-password"</span>, &hash)?;

<span class="comment">// JWTs are signed with HS256</span>
<span class="kw">use</span> chopin::auth::jwt;

<span class="kw">let</span> token = jwt::create_token(
    &user_id,             <span class="comment">// UUID string</span>
    &email,
    &role,                <span class="comment">// "user", "admin", "superuser"</span>
    &config.jwt_secret,
    config.jwt_expiry_hours,
)?;

<span class="kw">let</span> claims = jwt::validate_token(&token, &config.jwt_secret)?;
<span class="comment">// claims.sub = user_id, claims.email, claims.role</span></code></pre>
            </section>

            <!-- 8. Roles & Permissions -->
            <section id="roles" class="tutorial-section">
                <div class="section-number">08</div>
                <h2>Roles & Permissions</h2>
                <p>Chopin has a simple but effective <strong>hierarchical role system</strong>. Higher roles inherit all permissions of lower roles.</p>

                <div class="role-hierarchy">
                    <div class="role-card">
                        <div class="role-level">Level 0</div>
                        <h4>User</h4>
                        <p>Default role for new accounts</p>
                    </div>
                    <div class="role-arrow">&rarr;</div>
                    <div class="role-card">
                        <div class="role-level">Level 1</div>
                        <h4>Admin</h4>
                        <p>Can do everything User can + admin actions</p>
                    </div>
                    <div class="role-arrow">&rarr;</div>
                    <div class="role-card">
                        <div class="role-level">Level 2</div>
                        <h4>Superuser</h4>
                        <p>Full access to everything</p>
                    </div>
                </div>

                <h3>Protect routes by role</h3>
<pre><code><span class="kw">use</span> chopin::extractors::AuthUserWithRole;
<span class="kw">use</span> chopin::models::user::Role;

<span class="comment">// Only admins and superusers can access this</span>
<span class="kw">pub async fn</span> <span class="fn">admin_dashboard</span>(
    user: AuthUserWithRole&lt;{ Role::Admin <span class="kw">as</span> u8 }&gt;,
) -> <span class="kw">impl</span> IntoResponse {
    <span class="comment">// user.user_id, user.email, user.role are available</span>
    axum::Json(json!({ "message": "Welcome, admin!" }))
}

<span class="comment">// Or use the require_role middleware on a group of routes</span>
<span class="kw">use</span> chopin::extractors::require_role;

<span class="kw">fn</span> <span class="fn">admin_routes</span>() -> Router&lt;AppState&gt; {
    Router::new()
        .route(<span class="str">"/api/admin/users"</span>, get(list_users))
        .route(<span class="str">"/api/admin/stats"</span>, get(admin_stats))
        .layer(axum::middleware::from_fn(require_role::&lt;{ Role::Admin <span class="kw">as</span> u8 }&gt;))
}</code></pre>

                <h3>Create a superuser</h3>
<pre><code><span class="comment"># Via CLI</span>
chopin createsuperuser</code></pre>
            </section>

            <!-- 9. Extractors -->
            <section id="extractors" class="tutorial-section">
                <div class="section-number">09</div>
                <h2>Extractors</h2>
                <p>Extractors are Axum's way of parsing request data. Chopin provides custom extractors for common patterns.</p>

                <h3>AuthUser &mdash; JWT authentication</h3>
<pre><code><span class="kw">use</span> chopin::extractors::AuthUser;

<span class="comment">// Automatically validates the Bearer token from Authorization header</span>
<span class="kw">pub async fn</span> <span class="fn">get_profile</span>(user: AuthUser) -> <span class="kw">impl</span> IntoResponse {
    <span class="comment">// user.user_id: String (UUID)</span>
    <span class="comment">// user.email: String</span>
    <span class="comment">// user.role: String</span>
    axum::Json(json!({
        "id": user.user_id,
        "email": user.email,
        "role": user.role,
    }))
}</code></pre>

                <h3>Json &mdash; SIMD-accelerated body parsing</h3>
<pre><code><span class="kw">use</span> chopin::extractors::Json;

<span class="comment">// When `perf` feature is enabled, uses sonic-rs (SIMD)</span>
<span class="comment">// Otherwise falls back to serde_json</span>
<span class="kw">pub async fn</span> <span class="fn">create_item</span>(
    Json(payload): Json&lt;CreateItemRequest&gt;,
) -> <span class="kw">impl</span> IntoResponse {
    <span class="comment">// payload is deserialized from request body</span>
}</code></pre>

                <h3>Pagination &mdash; query parameter extraction</h3>
<pre><code><span class="kw">use</span> chopin::extractors::Pagination;

<span class="comment">// GET /api/posts?page=2&per_page=20</span>
<span class="kw">pub async fn</span> <span class="fn">list_items</span>(
    Query(pagination): Query&lt;Pagination&gt;,
) {
    <span class="kw">let</span> p = pagination.clamped(); <span class="comment">// Enforces min/max</span>
    <span class="comment">// p.page: clamped to 1..10000</span>
    <span class="comment">// p.per_page: clamped to 1..100</span>
    <span class="comment">// p.offset: computed as (page - 1) * per_page</span>
    <span class="comment">// p.limit: same as per_page</span>
}</code></pre>
            </section>

            <!-- 10. Pagination -->
            <section id="pagination" class="tutorial-section">
                <div class="section-number">10</div>
                <h2>Pagination</h2>
                <p>Chopin provides a complete pagination system with clamped values and a standardized response format.</p>

<pre><code><span class="kw">use</span> chopin::extractors::{Pagination, PaginatedResponse};

<span class="kw">pub async fn</span> <span class="fn">list_posts</span>(
    State(state): State&lt;AppState&gt;,
    Query(pagination): Query&lt;Pagination&gt;,
) -> axum::Json&lt;PaginatedResponse&lt;PostResponse&gt;&gt; {
    <span class="kw">let</span> p = pagination.clamped();

    <span class="comment">// Count total items</span>
    <span class="kw">let</span> total = Post::find().count(&state.db).<span class="kw">await</span>.unwrap_or(<span class="num">0</span>);

    <span class="comment">// Fetch page</span>
    <span class="kw">let</span> items = Post::find()
        .offset(p.offset)
        .limit(p.limit)
        .all(&state.db).<span class="kw">await</span>.unwrap_or_default()
        .into_iter().map(PostResponse::from).collect();

    axum::Json(PaginatedResponse::new(items, total, p.page, p.per_page))
}

<span class="comment">// Response format:</span>
<span class="comment">// {</span>
<span class="comment">//   "data": [...],</span>
<span class="comment">//   "pagination": {</span>
<span class="comment">//     "page": 1,</span>
<span class="comment">//     "per_page": 20,</span>
<span class="comment">//     "total": 150,</span>
<span class="comment">//     "total_pages": 8</span>
<span class="comment">//   }</span>
<span class="comment">// }</span></code></pre>
            </section>

            <!-- 11. Error Handling -->
            <section id="error-handling" class="tutorial-section">
                <div class="section-number">11</div>
                <h2>Error Handling</h2>
                <p>Chopin provides a unified error type that automatically maps to HTTP status codes and JSON responses.</p>

<pre><code><span class="kw">use</span> chopin::error::{ChopinError, FieldError};

<span class="comment">// Each variant maps to an HTTP status code</span>
ChopinError::NotFound(<span class="str">"User not found"</span>.into())         <span class="comment">// 404</span>
ChopinError::BadRequest(<span class="str">"Invalid input"</span>.into())         <span class="comment">// 400</span>
ChopinError::Unauthorized(<span class="str">"Invalid token"</span>.into())       <span class="comment">// 401</span>
ChopinError::Forbidden(<span class="str">"Not allowed"</span>.into())            <span class="comment">// 403</span>
ChopinError::Conflict(<span class="str">"Email already exists"</span>.into())   <span class="comment">// 409</span>
ChopinError::Internal(<span class="str">"Something broke"</span>.into())        <span class="comment">// 500</span>

<span class="comment">// All errors produce consistent JSON:</span>
<span class="comment">// { "success": false, "error": "User not found" }</span></code></pre>

                <h3>Field-level validation errors</h3>
<pre><code><span class="comment">// Return multiple field errors at once</span>
<span class="kw">let</span> errors = <span class="kw">vec!</span>[
    FieldError::new(<span class="str">"email"</span>, <span class="str">"must be a valid email address"</span>),
    FieldError::new(<span class="str">"password"</span>, <span class="str">"must be at least 8 characters"</span>),
];
<span class="kw">return</span> Err(ChopinError::ValidationErrors(errors));

<span class="comment">// Response (422):</span>
<span class="comment">// {</span>
<span class="comment">//   "success": false,</span>
<span class="comment">//   "error": "Validation failed",</span>
<span class="comment">//   "fields": [</span>
<span class="comment">//     { "field": "email", "message": "must be a valid email address" },</span>
<span class="comment">//     { "field": "password", "message": "must be at least 8 characters" }</span>
<span class="comment">//   ]</span>
<span class="comment">// }</span></code></pre>

                <h3>Using in handlers</h3>
<pre><code><span class="kw">use</span> chopin::error::ChopinError;
<span class="kw">use</span> chopin::response::ApiResponse;

<span class="kw">pub async fn</span> <span class="fn">get_post</span>(
    State(state): State&lt;AppState&gt;,
    Path(id): Path&lt;<span class="type">i32</span>&gt;,
) -> <span class="type">Result</span>&lt;axum::Json&lt;ApiResponse&lt;PostResponse&gt;&gt;, ChopinError&gt; {
    <span class="kw">let</span> post = Post::find_by_id(id)
        .one(&state.db).<span class="kw">await</span>
        .map_err(|e| ChopinError::Database(e.to_string()))?
        .ok_or_else(|| ChopinError::NotFound(<span class="kw">format!</span>(<span class="str">"Post {} not found"</span>, id)))?;

    <span class="type">Ok</span>(axum::Json(ApiResponse::success(PostResponse::from(post))))
}</code></pre>
            </section>

            <!-- 12. OpenAPI Docs -->
            <section id="openapi" class="tutorial-section">
                <div class="section-number">12</div>
                <h2>OpenAPI Documentation</h2>
                <p>Chopin auto-generates OpenAPI 3.0 documentation with <strong>Scalar UI</strong>. Your auth endpoints are documented automatically. Add your own endpoints with utoipa annotations.</p>

                <div class="callout">
                    <i data-lucide="external-link" class="inline-icon"></i>
                    <div>
                        Visit <code>http://localhost:3000/api-docs</code> after starting your server to see the interactive API documentation.
                    </div>
                </div>

                <h3>Annotate your handlers</h3>
<pre><code><span class="kw">use</span> utoipa::ToSchema;

<span class="attr">#[derive(Deserialize, ToSchema)]</span>
<span class="kw">pub struct</span> <span class="type">CreatePostRequest</span> {
    <span class="doc">/// Post title (required)</span>
    <span class="kw">pub</span> title: <span class="type">String</span>,
    <span class="doc">/// Post body content (required)</span>
    <span class="kw">pub</span> body: <span class="type">String</span>,
}

<span class="attr">#[utoipa::path(
    post,
    path = "/api/posts",
    tag = "posts",
    request_body = CreatePostRequest,
    responses(
        (status = 201, description = "Post created", body = ApiResponse&lt;PostResponse&gt;),
        (status = 400, description = "Invalid input")
    )
)]</span>
<span class="kw">pub async fn</span> <span class="fn">create_post</span>(...) { <span class="comment">/* ... */</span> }</code></pre>

                <h3>Custom OpenAPI doc</h3>
<pre><code><span class="kw">use</span> utoipa::OpenApi;

<span class="attr">#[derive(OpenApi)]</span>
<span class="attr">#[openapi(
    info(title = "My API", version = "1.0.0"),
    paths(
        controllers::posts::list_posts,
        controllers::posts::create_post,
    ),
    components(schemas(CreatePostRequest, PostResponse)),
    tags((name = "posts", description = "Post endpoints")),
    security(("bearer_auth" = []))
)]</span>
<span class="kw">pub struct</span> <span class="type">ApiDoc</span>;</code></pre>

                <h3>Export OpenAPI spec</h3>
<pre><code><span class="comment"># Export to JSON file</span>
chopin docs export --format json --output openapi.json

<span class="comment"># Export as YAML</span>
chopin docs export --format yaml --output openapi.yaml</code></pre>
            </section>

            <!-- 13. Caching -->
            <section id="caching" class="tutorial-section">
                <div class="section-number">13</div>
                <h2>Caching</h2>
                <p>Chopin provides a unified caching API with two backends: <strong>in-memory</strong> (default) and <strong>Redis</strong> (feature-gated). Cache any serializable data with TTL support.</p>

                <h3>In-memory cache (default)</h3>
<pre><code><span class="comment">// CacheService is automatically available via AppState</span>
<span class="comment">// when using App::new()</span>

<span class="kw">use</span> chopin::cache::CacheService;

<span class="kw">let</span> cache = CacheService::in_memory();

<span class="comment">// Basic string operations</span>
cache.set(<span class="str">"key"</span>, <span class="str">"value"</span>).<span class="kw">await</span>?;
<span class="kw">let</span> val = cache.get(<span class="str">"key"</span>).<span class="kw">await</span>?;            <span class="comment">// Option&lt;String&gt;</span>

<span class="comment">// With TTL (seconds)</span>
cache.set_with_ttl(<span class="str">"key"</span>, <span class="str">"value"</span>, <span class="num">300</span>).<span class="kw">await</span>?;  <span class="comment">// 5 minutes</span>

<span class="comment">// JSON operations â€” cache any Serialize/Deserialize type</span>
cache.set_json(<span class="str">"post:1"</span>, &post_response).<span class="kw">await</span>?;
<span class="kw">let</span> cached: Option&lt;PostResponse&gt; = cache.get_json(<span class="str">"post:1"</span>).<span class="kw">await</span>?;

<span class="comment">// Other operations</span>
cache.delete(<span class="str">"key"</span>).<span class="kw">await</span>?;
cache.exists(<span class="str">"key"</span>).<span class="kw">await</span>?;                    <span class="comment">// bool</span>
cache.flush().<span class="kw">await</span>?;                            <span class="comment">// Clear all</span></code></pre>

                <h3>Redis cache</h3>
<pre><code><span class="comment"># Enable in Cargo.toml</span>
chopin = { version = "0.1", features = ["redis"] }

<span class="comment"># Set in .env</span>
REDIS_URL=redis://127.0.0.1:6379</code></pre>

<pre><code><span class="comment">// Redis backend is used automatically when REDIS_URL is set</span>
<span class="comment">// The API is identical â€” same methods, same types</span>
<span class="kw">let</span> cache = CacheService::redis(<span class="str">"redis://127.0.0.1:6379"</span>).<span class="kw">await</span>?;</code></pre>

                <h3>Caching in handlers</h3>
<pre><code><span class="kw">pub async fn</span> <span class="fn">get_post</span>(
    State(state): State&lt;AppState&gt;,
    Path(id): Path&lt;<span class="type">i32</span>&gt;,
) -> <span class="type">Result</span>&lt;axum::Json&lt;ApiResponse&lt;PostResponse&gt;&gt;, ChopinError&gt; {
    <span class="kw">let</span> cache_key = <span class="kw">format!</span>(<span class="str">"post:{}"</span>, id);

    <span class="comment">// Check cache first</span>
    <span class="kw">if let</span> Some(cache) = &state.cache {
        <span class="kw">if let</span> Ok(Some(cached)) = cache.get_json::&lt;PostResponse&gt;(&cache_key).<span class="kw">await</span> {
            <span class="kw">return</span> <span class="type">Ok</span>(axum::Json(ApiResponse::success(cached)));
        }
    }

    <span class="comment">// Fetch from database</span>
    <span class="kw">let</span> post = Post::find_by_id(id).one(&state.db).<span class="kw">await</span>?
        .ok_or_else(|| ChopinError::NotFound(<span class="str">"Post not found"</span>.into()))?;
    <span class="kw">let</span> response = PostResponse::from(post);

    <span class="comment">// Store in cache for 5 minutes</span>
    <span class="kw">if let</span> Some(cache) = &state.cache {
        <span class="kw">let</span> _ = cache.set_json(&cache_key, &response).<span class="kw">await</span>;
    }

    <span class="type">Ok</span>(axum::Json(ApiResponse::success(response)))
}</code></pre>
            </section>

            <!-- 14. File Uploads -->
            <section id="file-uploads" class="tutorial-section">
                <div class="section-number">14</div>
                <h2>File Uploads</h2>
                <p>Upload files to <strong>local disk</strong> or <strong>S3-compatible storage</strong> (AWS S3, Cloudflare R2, MinIO). Chopin handles multipart parsing, validation, and storage.</p>

                <h3>Local storage</h3>
<pre><code><span class="kw">use</span> chopin::storage::{LocalStorage, FileUploadService};
<span class="kw">use</span> axum::extract::Multipart;

<span class="kw">let</span> storage = LocalStorage::new(<span class="str">"./uploads"</span>);
<span class="kw">let</span> upload_service = FileUploadService::new(
    Box::new(storage),
    <span class="num">10</span> * <span class="num">1024</span> * <span class="num">1024</span>,  <span class="comment">// 10MB max size</span>
);

<span class="kw">pub async fn</span> <span class="fn">upload_file</span>(
    <span class="kw">mut</span> multipart: Multipart,
) -> <span class="type">Result</span>&lt;<span class="kw">impl</span> IntoResponse, ChopinError&gt; {
    <span class="comment">// Process single file from multipart form</span>
    <span class="kw">let</span> uploaded = upload_service
        .process_single_upload(&<span class="kw">mut</span> multipart, <span class="str">"file"</span>)
        .<span class="kw">await</span>?;

    <span class="comment">// uploaded.filename: original filename</span>
    <span class="comment">// uploaded.stored_path: "uploads/uuid-filename.ext"</span>
    <span class="comment">// uploaded.content_type: "image/png"</span>
    <span class="comment">// uploaded.size: bytes</span>

    <span class="type">Ok</span>(axum::Json(json!({ "path": uploaded.stored_path })))
}</code></pre>

                <h3>S3 / Cloudflare R2 / MinIO</h3>
<pre><code><span class="comment"># Enable in Cargo.toml</span>
chopin = { version = "0.1", features = ["s3"] }

<span class="comment"># Configure in .env</span>
S3_BUCKET=my-bucket
S3_REGION=us-east-1
S3_ACCESS_KEY=AKIA...
S3_SECRET_KEY=...
S3_PUBLIC_URL=https://cdn.example.com

<span class="comment"># For Cloudflare R2</span>
S3_ENDPOINT=https://&lt;account-id&gt;.r2.cloudflarestorage.com

<span class="comment"># For MinIO</span>
S3_ENDPOINT=http://localhost:9000</code></pre>

<pre><code><span class="kw">use</span> chopin::storage::S3Storage;
<span class="kw">use</span> chopin::config::Config;

<span class="kw">let</span> config = Config::from_env()?;
<span class="kw">let</span> s3 = S3Storage::from_config(&config).<span class="kw">await</span>;

<span class="comment">// Same API as LocalStorage</span>
<span class="kw">let</span> upload_service = FileUploadService::new(
    Box::new(s3),
    config.max_upload_size,
);

<span class="comment">// Files are stored as: {prefix}/{uuid}-{filename}</span>
<span class="comment">// e.g., uploads/550e8400-e29b-41d4-a716-446655440000-photo.jpg</span></code></pre>
            </section>

            <!-- 15. GraphQL -->
            <section id="graphql" class="tutorial-section">
                <div class="section-number">15</div>
                <h2>GraphQL</h2>
                <p>Chopin includes optional GraphQL support via <code>async-graphql</code>. Enable it with the <code>graphql</code> feature flag.</p>

<pre><code><span class="comment"># Cargo.toml</span>
chopin = { version = "0.1", features = ["graphql"] }</code></pre>

<pre><code><span class="kw">use</span> async_graphql::{Object, Schema, EmptyMutation, EmptySubscription};
<span class="kw">use</span> chopin::graphql::graphql_routes;

<span class="kw">struct</span> <span class="type">QueryRoot</span>;

<span class="attr">#[Object]</span>
<span class="kw">impl</span> <span class="type">QueryRoot</span> {
    <span class="kw">async fn</span> <span class="fn">hello</span>(&self) -> &<span class="type">str</span> {
        <span class="str">"Hello from Chopin GraphQL!"</span>
    }

    <span class="kw">async fn</span> <span class="fn">posts</span>(&self) -> Vec&lt;<span class="type">String</span>&gt; {
        <span class="kw">vec!</span>[<span class="str">"Post 1"</span>.into(), <span class="str">"Post 2"</span>.into()]
    }
}

<span class="comment">// Build schema</span>
<span class="kw">let</span> schema = Schema::build(<span class="type">QueryRoot</span>, EmptyMutation, EmptySubscription)
    .finish();

<span class="comment">// Add to your router â€” provides:</span>
<span class="comment">// POST /graphql â€” endpoint</span>
<span class="comment">// GET /graphql  â€” GraphQL Playground UI</span>
<span class="kw">let</span> graphql = graphql_routes(schema);</code></pre>
            </section>

            <!-- 16. Testing -->
            <section id="testing" class="tutorial-section">
                <div class="section-number">16</div>
                <h2>Testing</h2>
                <p>Chopin provides a built-in test harness with <strong>in-memory SQLite</strong>, a test client, and response assertions. Write integration tests with zero configuration.</p>

                <h3>TestApp &mdash; spin up a test server</h3>
<pre><code><span class="kw">use</span> chopin::testing::{TestApp, TestClient};

<span class="attr">#[tokio::test]</span>
<span class="kw">async fn</span> <span class="fn">test_signup_and_login</span>() {
    <span class="comment">// Creates in-memory SQLite DB, runs all migrations</span>
    <span class="kw">let</span> test_app = TestApp::new().<span class="kw">await</span>;
    <span class="kw">let</span> client = test_app.client();

    <span class="comment">// Sign up</span>
    <span class="kw">let</span> res = client.post_json(
        <span class="str">"/api/auth/signup"</span>,
        <span class="str">r#"{"email":"test@example.com","password":"password123","name":"Test"}"#</span>,
    ).<span class="kw">await</span>;

    assert_eq!(res.status, <span class="num">200</span>);
    assert!(res.is_success());

    <span class="comment">// Extract token from response</span>
    <span class="kw">let</span> token = res.data()[<span class="str">"token"</span>].as_str().unwrap();

    <span class="comment">// Login</span>
    <span class="kw">let</span> res = client.post_json(
        <span class="str">"/api/auth/login"</span>,
        <span class="str">r#"{"email":"test@example.com","password":"password123"}"#</span>,
    ).<span class="kw">await</span>;

    assert_eq!(res.status, <span class="num">200</span>);
    assert!(res.is_success());
}</code></pre>

                <h3>Authenticated requests</h3>
<pre><code><span class="attr">#[tokio::test]</span>
<span class="kw">async fn</span> <span class="fn">test_protected_endpoint</span>() {
    <span class="kw">let</span> test_app = TestApp::new().<span class="kw">await</span>;
    <span class="kw">let</span> client = test_app.client();

    <span class="comment">// Sign up to get a token</span>
    <span class="kw">let</span> res = client.post_json(<span class="str">"/api/auth/signup"</span>, <span class="str">r#"{"email":"a@b.com","password":"pass1234","name":"A"}"#</span>).<span class="kw">await</span>;
    <span class="kw">let</span> token = res.data()[<span class="str">"token"</span>].as_str().unwrap().to_string();

    <span class="comment">// Make authenticated requests</span>
    <span class="kw">let</span> res = client.get_with_auth(<span class="str">"/api/profile"</span>, &token).<span class="kw">await</span>;
    assert_eq!(res.status, <span class="num">200</span>);

    <span class="comment">// POST with auth</span>
    <span class="kw">let</span> res = client.post_with_auth(
        <span class="str">"/api/posts"</span>, &token,
        <span class="str">r#"{"title":"Test","body":"Content"}"#</span>,
    ).<span class="kw">await</span>;
    assert_eq!(res.status, <span class="num">201</span>);
}</code></pre>

                <h3>TestResponse helpers</h3>
<pre><code><span class="kw">let</span> res = client.get(<span class="str">"/"</span>).<span class="kw">await</span>;

res.status         <span class="comment">// u16 â€” HTTP status code</span>
res.body           <span class="comment">// String â€” raw response body</span>
res.json()         <span class="comment">// serde_json::Value</span>
res.is_success()   <span class="comment">// checks json["success"] == true</span>
res.data()         <span class="comment">// json["data"]</span>
res.error()        <span class="comment">// json["error"]</span></code></pre>

<pre><code><span class="comment"># Run all tests</span>
cargo test --all

<span class="comment"># Run specific test</span>
cargo test test_signup_and_login -- --nocapture</code></pre>
            </section>

            <!-- 17. Performance -->
            <section id="performance" class="tutorial-section">
                <div class="section-number">17</div>
                <h2>Performance</h2>
                <p>Chopin uses a unified <strong>ChopinService</strong> dispatcher for all requests. FastRoute endpoints bypass Axum with zero allocation, and all other routes go through the full middleware stack. Enable <strong>SO_REUSEPORT</strong> for multi-core parallelism.</p>

                <div class="mode-comparison">
                    <div class="mode-card">
                        <h4><i data-lucide="shield" class="inline-icon"></i> Default</h4>
                        <ul>
                            <li>Single listener, multi-thread tokio</li>
                            <li>FastRoute zero-alloc fast path</li>
                            <li>Full Axum middleware for other routes</li>
                            <li>~150K-300K req/s</li>
                        </ul>
                        <code>cargo run --release</code>
                    </div>
                    <div class="mode-card">
                        <h4><i data-lucide="zap" class="inline-icon"></i> REUSEPORT=true</h4>
                        <ul>
                            <li>Per-core current_thread tokio runtimes</li>
                            <li>SO_REUSEPORT kernel-level load balancing</li>
                            <li>Zero cross-thread synchronization</li>
                            <li>~500K-1.7M+ req/s</li>
                        </ul>
                        <code>REUSEPORT=true cargo run --release</code>
                    </div>
                </div>

                <h3>Fast routes &mdash; zero-allocation endpoints</h3>
                <p>FastRoute bypasses Axum middleware for maximum performance. Each route can be individually configured with <strong>decorators</strong> â€” all pre-computed at registration time with zero per-request overhead.</p>

<h4>Basic usage</h4>
<pre><code><span class="kw">use</span> chopin::{App, FastRoute};

<span class="kw">let</span> app = App::new().<span class="kw">await</span>?
    <span class="comment">// Bare: maximum performance, no middleware (benchmark endpoints)</span>
    .fast_route(FastRoute::json(<span class="str">"/json"</span>, <span class="kw">br#</span><span class="str">{"message":"Hello, World!"}</span><span class="kw">#</span>))
    .fast_route(FastRoute::text(<span class="str">"/plaintext"</span>, <span class="kw">b</span><span class="str">"Hello, World!"</span>));

app.run().<span class="kw">await</span>?;</code></pre>

<h4>With CORS (frontend-accessible endpoints)</h4>
<pre><code><span class="kw">use</span> chopin::{App, FastRoute};

<span class="kw">let</span> app = App::new().<span class="kw">await</span>?
    <span class="comment">// Status endpoint with CORS + automatic OPTIONS preflight</span>
    .fast_route(
        FastRoute::json(<span class="str">"/api/status"</span>, <span class="kw">br#</span><span class="str">{"status":"ok"}</span><span class="kw">#</span>)
            .cors()                              <span class="comment">// adds Access-Control-Allow-Origin: *</span>
            .get_only()                          <span class="comment">// only GET/HEAD; POST falls through to Axum</span>
            .cache_control(<span class="str">"public, max-age=5"</span>)  <span class="comment">// static Cache-Control header</span>
    );

app.run().<span class="kw">await</span>?;</code></pre>

<h4>With custom headers</h4>
<pre><code><span class="kw">use</span> chopin::{App, FastRoute};
<span class="kw">use</span> axum::http::header;

<span class="kw">let</span> app = App::new().<span class="kw">await</span>?
    <span class="comment">// Health endpoint with security headers</span>
    .fast_route(
        FastRoute::text(<span class="str">"/health"</span>, <span class="kw">b</span><span class="str">"OK"</span>)
            .header(header::X_CONTENT_TYPE_OPTIONS, <span class="str">"nosniff"</span>)
            .header(header::X_FRAME_OPTIONS, <span class="str">"DENY"</span>)
            .cache_control(<span class="str">"no-cache"</span>)
    );

app.run().<span class="kw">await</span>?;</code></pre>

<h4>Per-route trade-offs</h4>
<table>
    <thead>
        <tr>
            <th>Feature</th>
            <th>FastRoute (bare)</th>
            <th>FastRoute (+decorators)</th>
            <th>Axum Router</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><strong>Performance</strong></td>
            <td>~35ns</td>
            <td>~35ns</td>
            <td>~1,000-5,000ns</td>
        </tr>
        <tr>
            <td><strong>Throughput</strong></td>
            <td>~28M req/s</td>
            <td>~28M req/s</td>
            <td>~200K-1M req/s</td>
        </tr>
        <tr>
            <td>CORS</td>
            <td>â€”</td>
            <td><code>.cors()</code></td>
            <td>CorsLayer</td>
        </tr>
        <tr>
            <td>Cache-Control</td>
            <td>â€”</td>
            <td><code>.cache_control()</code></td>
            <td>manual</td>
        </tr>
        <tr>
            <td>Method filter</td>
            <td>â€”</td>
            <td><code>.get_only()</code> / <code>.methods()</code></td>
            <td>built-in</td>
        </tr>
        <tr>
            <td>Auth</td>
            <td>â€”</td>
            <td>â€”</td>
            <td>middleware</td>
        </tr>
        <tr>
            <td>Logging</td>
            <td>â€”</td>
            <td>â€”</td>
            <td>TraceLayer</td>
        </tr>
    </tbody>
</table>

<div class="tip">
    <strong>When to use FastRoute:</strong>
    <ul>
        <li><strong>Health checks</strong> â€” <code>/health</code>, <code>/ready</code>, <code>/metrics</code></li>
        <li><strong>Static API responses</strong> â€” <code>/api/status</code>, <code>/api/version</code></li>
        <li><strong>Benchmark endpoints</strong> â€” <code>/json</code>, <code>/plaintext</code></li>
    </ul>
    <strong>When to use Axum Router:</strong>
    <ul>
        <li>Dynamic content (database queries, user input)</li>
        <li>Authentication required</li>
        <li>Request logging/tracing</li>
    </ul>
</div>

                <h3>How it works</h3>
                <div class="arch-flow">
<pre><code><span class="comment">ChopinService::call(req)  â† all requests go through this
  1. CORS preflight? (OPTIONS + .cors() enabled)
     â†’ pre-baked 204 No Content with CORS headers
  2. FastRoute path match + method allowed?
     â†’ pre-baked response (ZERO heap alloc, ~35ns)
  3. Axum Router
     â†’ full middleware stack (CORS, auth, tracing, etc.)

Request examples:
  GET /json            â†’ FastRoute (bare, ~35ns)
  GET /api/status      â†’ FastRoute (+cors, ~35ns)
  OPTIONS /api/status  â†’ FastRoute (204 preflight, automatic)
  POST /api/status     â†’ Axum (method not allowed on FastRoute)
  GET /users           â†’ Axum (dynamic content)

With REUSEPORT=true:
  SO_REUSEPORT x N CPU cores (kernel-level load balancing)
    â†’ per-core accept loop (current_thread runtime)
      â†’ TCP_NODELAY
        â†’ hyper HTTP/1.1 (keep-alive, pipeline_flush)
          â†’ ChopinService</span></code></pre>
                </div>

                <h3>Performance optimizations</h3>
                <div class="perf-grid">
                    <div class="perf-item">
                        <strong>mimalloc</strong>
                        <p>Global allocator replacing system malloc. Faster for multi-threaded workloads.</p>
                    </div>
                    <div class="perf-item">
                        <strong>sonic-rs</strong>
                        <p>SIMD-accelerated JSON. 2-3x faster than serde_json for parsing and serialization.</p>
                    </div>
                    <div class="perf-item">
                        <strong>Date header cache</strong>
                        <p>Lock-free AtomicU64 + thread-local cache. Updated every 500ms. ~8ns per request vs ~100ns.</p>
                    </div>
                    <div class="perf-item">
                        <strong>SO_REUSEPORT</strong>
                        <p>Kernel distributes TCP connections across cores. Eliminates accept() contention.</p>
                    </div>
                </div>

                <h3>Cargo.toml profile for benchmarks</h3>
<pre><code><span class="comment"># Cargo.toml â€” add this for maximum throughput</span>
[profile.release]
lto = "fat"
codegen-units = 1
opt-level = 3
strip = true

[profile.release.build-override]
opt-level = 3</code></pre>

                <h3>Benchmark with wrk</h3>
<pre><code><span class="comment"># Start server with SO_REUSEPORT</span>
REUSEPORT=true cargo run --release

<span class="comment"># Benchmark (in another terminal)</span>
wrk -t4 -c256 -d10s http://127.0.0.1:3000/json
wrk -t4 -c256 -d10s http://127.0.0.1:3000/plaintext</code></pre>
            </section>

            <!-- 18. Production Deployment -->
            <section id="production" class="tutorial-section">
                <div class="section-number">18</div>
                <h2>Production Deployment</h2>
                <p>Ship your Chopin API to production with a compiled Rust binary. No runtime, no garbage collector, no cold starts.</p>

                <h3>Build for production</h3>
<pre><code><span class="comment"># Optimized release build</span>
cargo build --release

<span class="comment"># With performance features</span>
cargo build --release --features perf

<span class="comment"># Result: a single static binary</span>
ls -lh target/release/my-api
<span class="comment"># -rwxr-xr-x  1 user  staff  12M  my-api</span></code></pre>

                <h3>Production .env</h3>
<pre><code><span class="comment"># Production environment</span>
ENVIRONMENT=production
REUSEPORT=true                  <span class="comment"># enable multi-core SO_REUSEPORT</span>
SERVER_HOST=0.0.0.0
SERVER_PORT=3000

<span class="comment"># Production database</span>
DATABASE_URL=postgres://user:pass@db.example.com/myapp

<span class="comment"># Strong JWT secret (generate with: openssl rand -hex 64)</span>
JWT_SECRET=your-very-long-random-secret-here
JWT_EXPIRY_HOURS=24

<span class="comment"># Redis for caching</span>
REDIS_URL=redis://redis.example.com:6379

<span class="comment"># S3 for file uploads</span>
S3_BUCKET=prod-uploads
S3_REGION=us-east-1
S3_ACCESS_KEY=AKIA...
S3_SECRET_KEY=...
S3_PUBLIC_URL=https://cdn.example.com</code></pre>

                <h3>Docker</h3>
<pre><code><span class="comment"># Dockerfile</span>
FROM rust:1.82-slim AS builder
WORKDIR /app
COPY . .
RUN cargo build --release --features perf

FROM debian:bookworm-slim
RUN apt-get update && apt-get install -y ca-certificates && rm -rf /var/lib/apt/lists/*
COPY --from=builder /app/target/release/my-api /usr/local/bin/
EXPOSE 3000
CMD ["my-api"]</code></pre>

<pre><code><span class="comment"># Build and run</span>
docker build -t my-api .
docker run -p 3000:3000 --env-file .env my-api</code></pre>

                <h3>Systemd service</h3>
<pre><code><span class="comment"># /etc/systemd/system/my-api.service</span>
[Unit]
Description=My Chopin API
After=network.target postgresql.service

[Service]
Type=simple
User=www-data
WorkingDirectory=/opt/my-api
EnvironmentFile=/opt/my-api/.env
ExecStart=/opt/my-api/my-api
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target</code></pre>

<pre><code><span class="comment"># Deploy</span>
sudo systemctl daemon-reload
sudo systemctl enable my-api
sudo systemctl start my-api
sudo systemctl status my-api</code></pre>

                <h3>Production checklist</h3>
                <div class="checklist">
                    <label><input type="checkbox"> Change <code>JWT_SECRET</code> to a strong random value</label>
                    <label><input type="checkbox"> Set <code>ENVIRONMENT=production</code></label>
                    <label><input type="checkbox"> Use PostgreSQL or MySQL instead of SQLite</label>
                    <label><input type="checkbox"> Set up Redis for caching</label>
                    <label><input type="checkbox"> Configure S3/R2 for file uploads</label>
                    <label><input type="checkbox"> Build with <code>--release --features perf</code></label>
                    <label><input type="checkbox"> Set up HTTPS via reverse proxy (nginx/Caddy)</label>
                    <label><input type="checkbox"> Configure logging and monitoring</label>
                    <label><input type="checkbox"> Set up database backups</label>
                    <label><input type="checkbox"> Run <code>cargo test --all</code> before deploying</label>
                </div>
            </section>

            <!-- Final CTA -->
            <section class="tutorial-cta">
                <h2>Start Building</h2>
                <p>You now know everything Chopin has to offer. From a 4-line hello world to a production-deployed API with auth, caching, file uploads, and 657K+ req/s performance.</p>
                <div class="cta-actions">
                    <a href="https://github.com/kowito/chopin" class="btn-primary">View on GitHub</a>
                    <a href="https://github.com/kowito/chopin/tree/main/chopin-examples" class="btn-secondary">Browse Examples</a>
                    <a href="https://docs.rs/chopin" class="btn-secondary">API Reference</a>
                </div>
            </section>

        </main>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-bottom" style="border-top: none; padding-top: 0;">
                <div class="footer-bottom-left">
                    <p>&copy; 2026 Chopin. All rights reserved.</p>
                </div>
                <div class="footer-bottom-right">
                    <p>Made with <i data-lucide="music" class="inline-icon-sm"></i> by the <a href="https://github.com/kowito">Chopin team</a></p>
                </div>
            </div>
        </div>
    </footer>

    <script src="js/main.js"></script>
    <script>
        lucide.createIcons();

        // Active TOC highlighting on scroll
        const sections = document.querySelectorAll('.tutorial-section');
        const tocLinks = document.querySelectorAll('.toc-link');

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    tocLinks.forEach(link => link.classList.remove('active'));
                    const id = entry.target.getAttribute('id');
                    const activeLink = document.querySelector(`.toc-link[href="#${id}"]`);
                    if (activeLink) activeLink.classList.add('active');
                }
            });
        }, { rootMargin: '-80px 0px -60% 0px' });

        sections.forEach(section => observer.observe(section));
    </script>
</body>
</html>
