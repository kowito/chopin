<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Chopin Tutorial - Complete guide to building production-ready APIs with the fastest Rust web framework.">
    <title>Tutorial - Chopin Framework</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/tutorial.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&family=Caveat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
</head>
<body>
    <!-- Navigation -->
    <nav class="nav">
        <div class="container">
            <div class="nav-content">
                <div class="nav-logo">
                    <a href="index.html" style="display:flex;align-items:center;gap:0.75rem;text-decoration:none;color:inherit;">
                        <i data-lucide="music" class="logo-icon"></i>
                        <span class="logo-text">Chopin</span>
                    </a>
                </div>
                <div class="nav-links">
                    <a href="index.html#features">Features</a>
                    <a href="index.html#benchmarks">Benchmarks</a>
                    <a href="tutorial.html" class="active">Tutorial</a>
                    <a href="https://docs.rs/chopin">API Docs</a>
                    <a href="https://github.com/kowito/chopin" class="btn-primary">GitHub</a>
                </div>
            </div>
        </div>
    </nav>

    <div class="tutorial-layout">
        <!-- Sidebar TOC -->
        <aside class="tutorial-sidebar">
            <div class="toc">
                <h3 class="toc-title">Tutorial</h3>
                <ol class="toc-list">
                    <li><a href="#installation" class="toc-link">Installation</a></li>
                    <li><a href="#hello-world" class="toc-link">Hello World</a></li>
                    <li><a href="#debugging" class="toc-link">Debugging & Logging</a></li>
                    <li><a href="#configuration" class="toc-link">Configuration</a></li>
                    <li><a href="#database" class="toc-link">Database & Models</a></li>
                    <li><a href="#migrations" class="toc-link">Migrations</a></li>
                    <li><a href="#controllers" class="toc-link">Controllers & Routing</a></li>
                    <li><a href="#authentication" class="toc-link">Authentication</a></li>
                    <li><a href="#security" class="toc-link">Security Features</a></li>
                    <li><a href="#roles" class="toc-link">Roles & Permissions</a></li>
                    <li><a href="#extractors" class="toc-link">Extractors</a></li>
                    <li><a href="#pagination" class="toc-link">Pagination</a></li>
                    <li><a href="#error-handling" class="toc-link">Error Handling</a></li>
                    <li><a href="#openapi" class="toc-link">API Documentation (OpenAPI)</a></li>
                    <li><a href="#caching" class="toc-link">Caching</a></li>
                    <li><a href="#file-uploads" class="toc-link">File Uploads</a></li>
                    <li><a href="#graphql" class="toc-link">GraphQL</a></li>
                    <li><a href="#testing" class="toc-link">Testing</a></li>
                    <li><a href="#performance" class="toc-link">Performance</a></li>
                    <li><a href="#production" class="toc-link">Production Deployment</a></li>
                </ol>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="tutorial-content">

            <!-- Hero -->
            <div class="tutorial-hero">
                <h1>From Zero to Production</h1>
                <p>A complete guide to building high-performance APIs with Chopin. Every feature, every pattern, from your first line of code to production deployment.</p>
            </div>

            <!-- 1. Installation -->
            <section id="installation" class="tutorial-section">
                <div class="section-number">01</div>
                <h2>Installation</h2>
                <p>Chopin requires <strong>Rust 1.75+</strong>. Install the CLI tool and scaffold your first project in seconds.</p>

                <h3>Install the CLI</h3>
<pre><code><span class="comment"># Install Chopin CLI from crates.io</span>
cargo install chopin-cli</code></pre>

                <h3>Create a new project</h3>
<pre><code><span class="comment"># Scaffold a new Chopin project</span>
chopin new my-api
<span class="kw">cd</span> my-api

<span class="comment"># Your project structure:</span>
<span class="comment"># my-api/</span>
<span class="comment">#   Cargo.toml</span>
<span class="comment">#   .env</span>
<span class="comment">#   src/</span>
<span class="comment">#     main.rs</span>
<span class="comment">#     lib.rs</span>
<span class="comment">#     controllers/</span>
<span class="comment">#     models/</span>
<span class="comment">#     migrations/</span></code></pre>

                <h3>Or add to an existing project</h3>
<pre><code><span class="comment"># Add chopin as a dependency</span>
cargo add chopin

<span class="comment"># With optional features</span>
cargo add chopin-core --features redis,s3,graphql,perf</code></pre>

                <div class="callout">
                    <i data-lucide="info" class="inline-icon"></i>
                    <div>
                        <strong>Feature flags:</strong>
                        <code>redis</code> &mdash; Redis caching backend,
                        <code>s3</code> &mdash; S3/R2/MinIO file storage,
                        <code>graphql</code> &mdash; GraphQL support,
                        <code>perf</code> &mdash; mimalloc + sonic-rs SIMD JSON
                    </div>
                </div>
            </section>

            <!-- 2. Hello World -->
            <section id="hello-world" class="tutorial-section">
                <div class="section-number">02</div>
                <h2>Hello World</h2>
                <p>The simplest Chopin app is <strong>4 lines of code</strong>. It gives you a running server with auth endpoints, database, and OpenAPI docs out of the box.</p>

<pre><code><span class="kw">use</span> chopin_core::prelude::*;

<span class="attr">#[tokio::main]</span>
<span class="kw">async fn</span> <span class="fn">main</span>() -> <span class="type">Result</span>&lt;(), Box&lt;<span class="kw">dyn</span> std::error::Error&gt;&gt; {
    init_logging();  <span class="comment">// Enable console logs and request traces</span>

    <span class="kw">let</span> app = App::new().<span class="kw">await</span>?;
    app.run().<span class="kw">await</span>?;

    <span class="type">Ok</span>(())
}</code></pre>

<pre><code><span class="comment"># Run it</span>
cargo run

<span class="comment"># Output:</span>
<span class="comment"># üéπ Chopin is running</span>
<span class="comment">#    ‚Üí Server:    http://127.0.0.1:3000</span>
<span class="comment">#    ‚Üí API docs:  http://127.0.0.1:3000/api-docs</span>
<span class="comment">#    ‚Üí Mode:      standard</span></code></pre>

                <p>You already have these endpoints:</p>
                <div class="endpoint-table">
                    <table>
                        <thead>
                            <tr><th>Method</th><th>Path</th><th>Description</th></tr>
                        </thead>
                        <tbody>
                            <tr><td><span class="method get">GET</span></td><td><code>/</code></td><td>Welcome JSON</td></tr>
                            <tr><td><span class="method post">POST</span></td><td><code>/api/auth/signup</code></td><td>Create a user account</td></tr>
                            <tr><td><span class="method post">POST</span></td><td><code>/api/auth/login</code></td><td>Login (supports 2FA)</td></tr>
                            <tr><td><span class="method post">POST</span></td><td><code>/api/auth/logout</code></td><td>Logout &amp; revoke sessions</td></tr>
                            <tr><td><span class="method post">POST</span></td><td><code>/api/auth/refresh</code></td><td>Rotate refresh token</td></tr>
                            <tr><td><span class="method post">POST</span></td><td><code>/api/auth/totp/setup</code></td><td>Setup 2FA</td></tr>
                            <tr><td><span class="method post">POST</span></td><td><code>/api/auth/password-reset/request</code></td><td>Request password reset</td></tr>
                            <tr><td><span class="method post">POST</span></td><td><code>/api/auth/verify-email</code></td><td>Verify email address</td></tr>
                            <tr><td><span class="method get">GET</span></td><td><code>/api-docs</code></td><td>Scalar OpenAPI UI</td></tr>
                            <tr><td><span class="method get">GET</span></td><td><code>/api-docs/openapi.json</code></td><td>Raw OpenAPI spec</td></tr>
                        </tbody>
                    </table>
                </div>
            </section>

            <!-- 3. Debugging & Logging -->
            <section id="debugging" class="tutorial-section">
                <div class="section-number">03</div>
                <h2>Debugging & Logging</h2>
                <p>To see console output when your server handles requests, you must <strong>initialize logging</strong>. Without it, you won't see any logs, making debugging difficult.</p>

                <h3>Enable logging (required for debugging)</h3>
                <p>Call <code>init_logging()</code> at the start of your <code>main()</code> function, <strong>before</strong> creating the App:</p>

<pre><code><span class="kw">use</span> chopin_core::prelude::*;

<span class="attr">#[tokio::main]</span>
<span class="kw">async fn</span> <span class="fn">main</span>() -> <span class="type">Result</span>&lt;(), Box&lt;<span class="kw">dyn</span> std::error::Error&gt;&gt; {
    init_logging();  <span class="comment">// ‚Üê Add this line to enable console output</span>

    <span class="kw">let</span> app = App::new().<span class="kw">await</span>?;
    app.run().<span class="kw">await</span>?;
    <span class="type">Ok</span>(())
}</code></pre>

                <p>Now you'll see:</p>
<pre><code><span class="comment"># Server startup logs</span>
2026-02-15T23:00:00.123Z  INFO chopin_core::app: Running pending database migrations...
2026-02-15T23:00:00.234Z  INFO chopin_core::app: Migrations complete.
2026-02-15T23:00:00.345Z  INFO chopin_core::app: Using in-memory cache
2026-02-15T23:00:00.456Z  INFO chopin_core::app: Chopin server running on http://127.0.0.1:3000

<span class="comment"># HTTP request traces (in development mode)</span>
2026-02-15T23:00:05.123Z  INFO tower_http::trace::on_request: started processing request method=GET uri=/api/users
2026-02-15T23:00:05.125Z  INFO tower_http::trace::on_response: finished processing request latency=2 ms status=200</code></pre>

                <h3>Other logging options</h3>
                <p>Chopin provides four logging functions:</p>

                <div class="callout">
                    <i data-lucide="info" class="inline-icon"></i>
                    <div>
                        <strong>Logging functions:</strong>
                        <ul>
                            <li><code>init_logging()</code> ‚Äî Simple default, respects RUST_LOG env var</li>
                            <li><code>init_logging_with_level("debug")</code> ‚Äî Set level programmatically</li>
                            <li><code>init_logging_pretty()</code> ‚Äî Colorized output for development</li>
                            <li><code>init_logging_json()</code> ‚Äî JSON format for production log aggregation</li>
                        </ul>
                    </div>
                </div>

                <h3>Control log levels via environment variable</h3>
<pre><code><span class="comment"># Show all logs (very verbose)</span>
<span class="kw">RUST_LOG</span>=debug cargo run

<span class="comment"># Show only warnings and errors (production)</span>
<span class="kw">RUST_LOG</span>=warn cargo run

<span class="comment"># Fine-grained control per module</span>
<span class="kw">RUST_LOG</span>=chopin_core=debug,tower_http=debug,sqlx=warn cargo run</code></pre>

                <h3>Development vs Production</h3>
                <p>In <strong>development mode</strong> (<code>APP_ENV=development</code> or not set), Chopin automatically enables HTTP request tracing middleware. You'll see detailed logs for every request.</p>
                <p>In <strong>production mode</strong> (<code>APP_ENV=production</code>), request tracing is disabled by default for performance. You'll still see important logs like migrations, startup, and errors.</p>

                <div class="callout">
                    <i data-lucide="alert-circle" class="inline-icon"></i>
                    <div>
                        <strong>Common mistake:</strong> If you don't see any console output, make sure you called <code>init_logging()</code> before <code>App::new()</code>. This is the most common debugging issue for new users!
                    </div>
                </div>

                <p>For complete documentation, see the <a href="debugging-and-logging.md">Debugging & Logging Guide</a>.</p>
            </section>

            <!-- 4. Configuration -->
            <section id="configuration" class="tutorial-section">
                <div class="section-number">04</div>
                <h2>Configuration</h2>
                <p>Chopin loads configuration from environment variables via a <code>.env</code> file. Every setting has a sensible default.</p>

<pre><code><span class="comment"># .env ‚Äî Chopin configuration</span>

<span class="comment"># Server</span>
REUSEPORT=false               <span class="comment"># true for multi-core SO_REUSEPORT</span>
SERVER_HOST=127.0.0.1
SERVER_PORT=3000
ENVIRONMENT=development       <span class="comment"># development | production</span>

<span class="comment"># Database (SeaORM ‚Äî supports SQLite, PostgreSQL, MySQL)</span>
DATABASE_URL=sqlite://chopin.db?mode=rwc

<span class="comment"># Authentication</span>
JWT_SECRET=change-me-in-production
JWT_EXPIRY_HOURS=24

<span class="comment"># Security (all enabled by default ‚Äî set to false to disable)</span>
SECURITY_2FA=true
SECURITY_RATE_LIMIT=true
SECURITY_RATE_LIMIT_MAX=5
SECURITY_RATE_LIMIT_WINDOW=300
SECURITY_ACCOUNT_LOCKOUT=true
SECURITY_LOCKOUT_MAX=5
SECURITY_LOCKOUT_DURATION=900
SECURITY_REFRESH_TOKENS=true
SECURITY_REFRESH_EXPIRY_DAYS=30
SECURITY_SESSION_MANAGEMENT=true
SECURITY_PASSWORD_RESET=true
SECURITY_RESET_EXPIRY=3600
SECURITY_EMAIL_VERIFICATION=true
SECURITY_EMAIL_VERIFY_EXPIRY=86400
SECURITY_CSRF=true
SECURITY_DEVICE_TRACKING=true
SECURITY_MIN_PASSWORD_LENGTH=12

<span class="comment"># Redis (requires `redis` feature)</span>
REDIS_URL=redis://127.0.0.1:6379

<span class="comment"># File Uploads</span>
UPLOAD_DIR=./uploads
MAX_UPLOAD_SIZE=10485760      <span class="comment"># 10MB in bytes</span>

<span class="comment"># S3 Storage (requires `s3` feature)</span>
S3_BUCKET=my-bucket
S3_REGION=us-east-1
S3_ENDPOINT=                  <span class="comment"># For R2/MinIO</span>
S3_ACCESS_KEY=
S3_SECRET_KEY=
S3_PUBLIC_URL=                <span class="comment"># CDN or public URL prefix</span>
S3_PREFIX=uploads             <span class="comment"># Object key prefix</span></code></pre>

                <p>Access config in your code:</p>
<pre><code><span class="kw">use</span> chopin_core::config::Config;

<span class="kw">let</span> config = Config::from_env()?;

<span class="comment">// Useful helpers</span>
config.is_dev()       <span class="comment">// true if ENVIRONMENT=development</span>
config.has_s3()       <span class="comment">// true if S3_BUCKET is set</span>
config.server_addr()  <span class="comment">// "127.0.0.1:3000"</span></code></pre>

                <h3>Custom config with App</h3>
<pre><code><span class="comment">// Override config programmatically</span>
<span class="kw">let mut</span> config = Config::from_env()?;
config.server_port = <span class="num">8080</span>;

<span class="kw">let</span> app = App::with_config(config).<span class="kw">await</span>?;
app.run().<span class="kw">await</span>?;</code></pre>
            </section>

            <!-- 5. Database & Models -->
            <section id="database" class="tutorial-section">
                <div class="section-number">05</div>
                <h2>Database & Models</h2>
                <p>Chopin uses <strong>SeaORM</strong> for database access. It supports SQLite, PostgreSQL, and MySQL with the same code. Models are defined as Rust structs with derive macros.</p>

                <h3>Connection</h3>
                <p>Chopin connects automatically when you call <code>App::new()</code>. To connect manually:</p>
<pre><code><span class="kw">use</span> chopin_core::{config::Config, db};

<span class="kw">let</span> config = Config::from_env()?;
<span class="kw">let</span> conn = db::connect(&config).<span class="kw">await</span>?;

<span class="comment">// Connection pool is pre-configured:</span>
<span class="comment">// max_connections: 100, min_connections: 5</span>
<span class="comment">// connect_timeout: 8s, idle_timeout: 8s</span></code></pre>

                <h3>Defining a model</h3>
                <p>Use the CLI to scaffold, or define manually:</p>
<pre><code><span class="comment"># Generate model + migration + controller</span>
chopin generate model Post title:string body:text published:bool</code></pre>

<pre><code><span class="comment">// src/models/post.rs</span>
<span class="kw">use</span> chrono::NaiveDateTime;
<span class="kw">use</span> sea_orm::entity::prelude::*;
<span class="kw">use</span> serde::{Deserialize, Serialize};
<span class="kw">use</span> utoipa::ToSchema;

<span class="attr">#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel, Serialize, Deserialize)]</span>
<span class="attr">#[sea_orm(table_name = "posts")]</span>
<span class="kw">pub struct</span> <span class="type">Model</span> {
    <span class="attr">#[sea_orm(primary_key)]</span>
    <span class="kw">pub</span> id: <span class="type">i32</span>,
    <span class="kw">pub</span> title: <span class="type">String</span>,
    <span class="attr">#[sea_orm(column_type = "Text")]</span>
    <span class="kw">pub</span> body: <span class="type">String</span>,
    <span class="attr">#[sea_orm(default_value = "false")]</span>
    <span class="kw">pub</span> published: <span class="type">bool</span>,
    <span class="kw">pub</span> created_at: <span class="type">NaiveDateTime</span>,
    <span class="kw">pub</span> updated_at: <span class="type">NaiveDateTime</span>,
}

<span class="attr">#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]</span>
<span class="kw">pub enum</span> <span class="type">Relation</span> {}

<span class="kw">impl</span> ActiveModelBehavior <span class="kw">for</span> ActiveModel {}

<span class="comment">// Response DTO ‚Äî what clients see</span>
<span class="attr">#[derive(Debug, Serialize, Deserialize, ToSchema)]</span>
<span class="kw">pub struct</span> <span class="type">PostResponse</span> {
    <span class="kw">pub</span> id: <span class="type">i32</span>,
    <span class="kw">pub</span> title: <span class="type">String</span>,
    <span class="kw">pub</span> body: <span class="type">String</span>,
    <span class="kw">pub</span> published: <span class="type">bool</span>,
    <span class="kw">pub</span> created_at: <span class="type">String</span>,
    <span class="kw">pub</span> updated_at: <span class="type">String</span>,
}

<span class="kw">impl</span> From&lt;Model&gt; <span class="kw">for</span> <span class="type">PostResponse</span> {
    <span class="kw">fn</span> <span class="fn">from</span>(m: Model) -> <span class="type">Self</span> {
        <span class="type">PostResponse</span> {
            id: m.id,
            title: m.title,
            body: m.body,
            published: m.published,
            created_at: m.created_at.format(<span class="str">"%Y-%m-%dT%H:%M:%S"</span>).to_string(),
            updated_at: m.updated_at.format(<span class="str">"%Y-%m-%dT%H:%M:%S"</span>).to_string(),
        }
    }
}</code></pre>

                <h3>CRUD operations</h3>
<pre><code><span class="kw">use</span> sea_orm::*;
<span class="kw">use</span> crate::models::post::{self, Entity <span class="kw">as</span> Post};

<span class="comment">// Create</span>
<span class="kw">let</span> new = post::ActiveModel {
    title: Set(<span class="str">"Hello"</span>.into()),
    body: Set(<span class="str">"World"</span>.into()),
    ..Default::default()
};
<span class="kw">let</span> result = new.insert(&db).<span class="kw">await</span>?;

<span class="comment">// Read</span>
<span class="kw">let</span> post = Post::find_by_id(<span class="num">1</span>).one(&db).<span class="kw">await</span>?;
<span class="kw">let</span> all = Post::find().all(&db).<span class="kw">await</span>?;

<span class="comment">// Update</span>
<span class="kw">let mut</span> active: post::ActiveModel = post.unwrap().into();
active.title = Set(<span class="str">"Updated"</span>.into());
<span class="kw">let</span> updated = active.update(&db).<span class="kw">await</span>?;

<span class="comment">// Delete</span>
Post::delete_by_id(<span class="num">1</span>).exec(&db).<span class="kw">await</span>?;</code></pre>
            </section>

            <!-- 6. Migrations -->
            <section id="migrations" class="tutorial-section">
                <div class="section-number">06</div>
                <h2>Migrations</h2>
                <p>Migrations run <strong>automatically on startup</strong>. Chopin uses SeaORM's migration system &mdash; define them as Rust code, and they're applied when the app boots.</p>

<pre><code><span class="comment">// src/migrations/m20250101_000001_create_posts_table.rs</span>
<span class="kw">use</span> sea_orm_migration::{prelude::*, schema::*};

<span class="attr">#[derive(DeriveMigrationName)]</span>
<span class="kw">pub struct</span> <span class="type">Migration</span>;

<span class="attr">#[async_trait::async_trait]</span>
<span class="kw">impl</span> MigrationTrait <span class="kw">for</span> <span class="type">Migration</span> {
    <span class="kw">async fn</span> <span class="fn">up</span>(&self, manager: &SchemaManager) -> <span class="type">Result</span>&lt;(), DbErr&gt; {
        manager
            .create_table(
                Table::create()
                    .table(Posts::Table)
                    .if_not_exists()
                    .col(pk_auto(Posts::Id))
                    .col(string(Posts::Title))
                    .col(text(Posts::Body))
                    .col(boolean(Posts::Published).default(<span class="kw">false</span>))
                    .col(timestamp(Posts::CreatedAt))
                    .col(timestamp(Posts::UpdatedAt))
                    .to_owned(),
            )
            .<span class="kw">await</span>
    }

    <span class="kw">async fn</span> <span class="fn">down</span>(&self, manager: &SchemaManager) -> <span class="type">Result</span>&lt;(), DbErr&gt; {
        manager
            .drop_table(Table::drop().table(Posts::Table).to_owned())
            .<span class="kw">await</span>
    }
}

<span class="attr">#[derive(DeriveIden)]</span>
<span class="kw">enum</span> <span class="type">Posts</span> {
    Table, Id, Title, Body, Published, CreatedAt, UpdatedAt,
}</code></pre>

                <h3>Register migrations</h3>
<pre><code><span class="comment">// src/migrations/mod.rs</span>
<span class="kw">pub use</span> sea_orm_migration::prelude::*;

<span class="kw">mod</span> m20250101_000001_create_posts_table;

<span class="kw">pub struct</span> <span class="type">Migrator</span>;

<span class="attr">#[async_trait::async_trait]</span>
<span class="kw">impl</span> MigratorTrait <span class="kw">for</span> <span class="type">Migrator</span> {
    <span class="kw">fn</span> <span class="fn">migrations</span>() -> Vec&lt;Box&lt;<span class="kw">dyn</span> MigrationTrait&gt;&gt; {
        <span class="kw">vec!</span>[Box::new(m20250101_000001_create_posts_table::Migration)]
    }
}</code></pre>

                <h3>CLI migration commands</h3>
<pre><code><span class="comment"># Run pending migrations</span>
chopin db migrate

<span class="comment"># Rollback last migration</span>
chopin db rollback

<span class="comment"># Rollback N migrations</span>
chopin db rollback --steps 3

<span class="comment"># Show migration status</span>
chopin db status

<span class="comment"># Reset database (rollback all + migrate)</span>
chopin db reset</code></pre>
            </section>

            <!-- 7. Controllers & Routing -->
            <section id="controllers" class="tutorial-section">
                <div class="section-number">07</div>
                <h2>Controllers & Routing</h2>
                <p>Controllers are Axum handlers grouped into modules. Chopin follows the standard Axum routing pattern with shared application state.</p>

                <h3>Application state</h3>
<pre><code><span class="comment">// Chopin provides this built-in:</span>
<span class="attr">#[derive(Clone)]</span>
<span class="kw">pub struct</span> <span class="type">AppState</span> {
    <span class="kw">pub</span> db: DatabaseConnection,
    <span class="kw">pub</span> config: Config,
    <span class="kw">pub</span> cache: Option&lt;CacheService&gt;,
}</code></pre>

                <h3>Defining routes</h3>
<pre><code><span class="comment">// src/controllers/posts.rs</span>
<span class="kw">use</span> chopin_core::{extract::{Path, Query, State}, routing::get, Router};
<span class="kw">use</span> chopin_core::response::ApiResponse;
<span class="kw">use</span> crate::AppState;

<span class="kw">pub fn</span> <span class="fn">routes</span>() -> Router&lt;AppState&gt; {
    Router::new()
        .route(<span class="str">"/api/posts"</span>, get(list_posts).post(create_post))
        .route(<span class="str">"/api/posts/{id}"</span>, get(get_post).put(update_post).delete(delete_post))
}

<span class="kw">pub async fn</span> <span class="fn">list_posts</span>(
    State(state): State&lt;AppState&gt;,
    Query(pagination): Query&lt;Pagination&gt;,
) -> <span class="type">Result</span>&lt;chopin_core::Json&lt;ApiResponse&lt;Vec&lt;PostResponse&gt;&gt;&gt;, StatusCode&gt; {
    <span class="kw">let</span> posts = Post::find()
        .order_by_desc(post::Column::CreatedAt)
        .offset(pagination.clamped().offset)
        .limit(pagination.clamped().limit)
        .all(&state.db).<span class="kw">await</span>
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    <span class="type">Ok</span>(chopin_core::Json(ApiResponse::success(
        posts.into_iter().map(PostResponse::from).collect()
    )))
}

<span class="kw">pub async fn</span> <span class="fn">create_post</span>(
    State(state): State&lt;AppState&gt;,
    chopin_core::Json(payload): chopin_core::Json&lt;CreatePostRequest&gt;,
) -> <span class="type">Result</span>&lt;(StatusCode, chopin_core::Json&lt;ApiResponse&lt;PostResponse&gt;&gt;), StatusCode&gt; {
    <span class="kw">let</span> new = post::ActiveModel {
        title: Set(payload.title),
        body: Set(payload.body),
        ..Default::default()
    };
    <span class="kw">let</span> result = new.insert(&state.db).<span class="kw">await</span>
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    <span class="type">Ok</span>((StatusCode::CREATED, chopin_core::Json(ApiResponse::success(PostResponse::from(result)))))
}</code></pre>

                <h3>Generate a controller</h3>
<pre><code><span class="comment"># Scaffold CRUD controller</span>
chopin generate controller posts</code></pre>
            </section>

            <!-- 8. Authentication -->
            <section id="authentication" class="tutorial-section">
                <div class="section-number">08</div>
                <h2>Authentication</h2>
                <p>Chopin provides <strong>built-in JWT authentication</strong> with Argon2id password hashing. The <code>/api/auth/signup</code> and <code>/api/auth/login</code> endpoints are included automatically.</p>

                <h3>Sign up a user</h3>
<pre><code>curl -X POST http://localhost:3000/api/auth/signup \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "password": "securepassword123",
    "name": "John Doe"
  }'

<span class="comment"># Response:</span>
<span class="comment"># {</span>
<span class="comment">#   "success": true,</span>
<span class="comment">#   "data": {</span>
<span class="comment">#     "token": "eyJhbGciOiJIUzI1...",</span>
<span class="comment">#     "user": { "id": "uuid", "email": "user@example.com", "name": "John Doe", "role": "user" }</span>
<span class="comment">#   }</span>
<span class="comment"># }</span></code></pre>

                <h3>Log in</h3>
<pre><code>curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "password": "securepassword123"
  }'</code></pre>

                <h3>How it works internally</h3>
<pre><code><span class="comment">// Passwords are hashed with Argon2id (memory-hard, GPU-resistant)</span>
<span class="kw">use</span> chopin_core::auth::password;

<span class="kw">let</span> hash = password::hash_password(<span class="str">"my-password"</span>)?;
<span class="kw">let</span> valid = password::verify_password(<span class="str">"my-password"</span>, &hash)?;

<span class="comment">// JWTs are signed with HS256</span>
<span class="kw">use</span> chopin_core::auth::jwt;

<span class="kw">let</span> token = jwt::create_token(
    &user_id,             <span class="comment">// UUID string</span>
    &email,
    &role,                <span class="comment">// "user", "admin", "superuser"</span>
    &config.jwt_secret,
    config.jwt_expiry_hours,
)?;

<span class="kw">let</span> claims = jwt::validate_token(&token, &config.jwt_secret)?;
<span class="comment">// claims.sub = user_id, claims.email, claims.role</span></code></pre>
            </section>

            <!-- 8b. Security Features -->
            <section id="security" class="tutorial-section">
                <div class="section-number">08b</div>
                <h2>Security Features</h2>
                <p>Chopin includes <strong>9 production security features</strong>, all <strong>enabled by default</strong>. No extra code or config needed ‚Äî just deploy. Each feature can be individually disabled via environment variables.</p>

                <h3>Overview</h3>
                <table class="config-table">
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>What It Does</th>
                            <th>Env Var to Disable</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td><strong>2FA/TOTP</strong></td><td>Time-based One-Time Password (Google Authenticator compatible)</td><td><code>SECURITY_2FA=false</code></td></tr>
                        <tr><td><strong>Rate Limiting</strong></td><td>Blocks login after 5 attempts per 5 min window</td><td><code>SECURITY_RATE_LIMIT=false</code></td></tr>
                        <tr><td><strong>Account Lockout</strong></td><td>Locks account after 5 failed attempts for 15 min</td><td><code>SECURITY_ACCOUNT_LOCKOUT=false</code></td></tr>
                        <tr><td><strong>Refresh Tokens</strong></td><td>Automatic rotation with reuse detection</td><td><code>SECURITY_REFRESH_TOKENS=false</code></td></tr>
                        <tr><td><strong>Session Management</strong></td><td>Server-side sessions, revoke one or all</td><td><code>SECURITY_SESSION_MANAGEMENT=false</code></td></tr>
                        <tr><td><strong>Password Reset</strong></td><td>Secure token-based password reset flow</td><td><code>SECURITY_PASSWORD_RESET=false</code></td></tr>
                        <tr><td><strong>Email Verification</strong></td><td>Require email verification on signup</td><td><code>SECURITY_EMAIL_VERIFICATION=false</code></td></tr>
                        <tr><td><strong>CSRF Protection</strong></td><td>Token issued on login, verified on state-changing requests</td><td><code>SECURITY_CSRF=false</code></td></tr>
                        <tr><td><strong>IP/Device Tracking</strong></td><td>Audit log of all login events with IP and user agent</td><td><code>SECURITY_DEVICE_TRACKING=false</code></td></tr>
                    </tbody>
                </table>

                <h3>Auth Endpoints</h3>
                <p>When security features are enabled, the following endpoints are available under <code>/api/auth/</code>:</p>
                <table class="config-table">
                    <thead>
                        <tr>
                            <th>Method</th>
                            <th>Endpoint</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td><span class="method post">POST</span></td><td><code>/api/auth/signup</code></td><td>Create account (returns access + refresh + CSRF tokens)</td></tr>
                        <tr><td><span class="method post">POST</span></td><td><code>/api/auth/login</code></td><td>Login with optional TOTP code</td></tr>
                        <tr><td><span class="method post">POST</span></td><td><code>/api/auth/logout</code></td><td>Revoke current session or all sessions</td></tr>
                        <tr><td><span class="method post">POST</span></td><td><code>/api/auth/refresh</code></td><td>Rotate refresh token, get new access token</td></tr>
                        <tr><td><span class="method post">POST</span></td><td><code>/api/auth/totp/setup</code></td><td>Get TOTP secret + QR URI (requires auth)</td></tr>
                        <tr><td><span class="method post">POST</span></td><td><code>/api/auth/totp/enable</code></td><td>Verify &amp; enable 2FA (requires auth + TOTP code)</td></tr>
                        <tr><td><span class="method post">POST</span></td><td><code>/api/auth/totp/disable</code></td><td>Disable 2FA (requires auth + password + TOTP code)</td></tr>
                        <tr><td><span class="method post">POST</span></td><td><code>/api/auth/password-reset/request</code></td><td>Request a password reset token</td></tr>
                        <tr><td><span class="method post">POST</span></td><td><code>/api/auth/password-reset/confirm</code></td><td>Set new password with reset token</td></tr>
                        <tr><td><span class="method post">POST</span></td><td><code>/api/auth/verify-email</code></td><td>Verify email with verification token</td></tr>
                    </tbody>
                </table>

                <h3>2FA / TOTP Setup Flow</h3>
                <p>Users enable two-factor authentication in 3 steps:</p>
<pre><code><span class="comment"># 1. Setup ‚Äî get the TOTP secret and QR code URI</span>
curl -X POST http://localhost:3000/api/auth/totp/setup \
  -H "Authorization: Bearer &lt;access_token&gt;"

<span class="comment"># Response:</span>
<span class="comment"># { "secret": "JBSWY3DPEHPK3PXP", "otpauth_uri": "otpauth://totp/..." }</span>

<span class="comment"># 2. User scans QR code in Google Authenticator / Authy</span>
<span class="comment"># 3. Verify and enable with a code from the app:</span>
curl -X POST http://localhost:3000/api/auth/totp/enable \
  -H "Authorization: Bearer &lt;access_token&gt;" \
  -H "Content-Type: application/json" \
  -d '{ "code": "123456" }'

<span class="comment"># Future logins now require the totp_code field:</span>
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{ "email": "user@example.com", "password": "pw", "totp_code": "654321" }'</code></pre>

                <h3>Refresh Token Flow</h3>
                <p>Chopin uses <strong>automatic token rotation</strong> ‚Äî each refresh issues a new pair of tokens (access + refresh). Old refresh tokens are revoked. If a revoked refresh token is reused, <strong>all tokens for that user are revoked</strong> (detecting token theft).</p>
<pre><code><span class="comment"># Exchange refresh token for new access + refresh tokens</span>
curl -X POST http://localhost:3000/api/auth/refresh \
  -H "Content-Type: application/json" \
  -d '{ "refresh_token": "&lt;current_refresh_token&gt;" }'

<span class="comment"># Response:</span>
<span class="comment"># { "access_token": "eyJ...", "refresh_token": "new_token_here" }</span></code></pre>

                <h3>Password Reset Flow</h3>
<pre><code><span class="comment"># 1. Request reset (returns token ‚Äî in production, email it)</span>
curl -X POST http://localhost:3000/api/auth/password-reset/request \
  -H "Content-Type: application/json" \
  -d '{ "email": "user@example.com" }'

<span class="comment"># 2. Confirm with token + new password</span>
curl -X POST http://localhost:3000/api/auth/password-reset/confirm \
  -H "Content-Type: application/json" \
  -d '{ "token": "&lt;reset_token&gt;", "new_password": "newSecurePass123" }'</code></pre>

                <h3>Logout &amp; Session Revocation</h3>
<pre><code><span class="comment"># Logout current session</span>
curl -X POST http://localhost:3000/api/auth/logout \
  -H "Authorization: Bearer &lt;access_token&gt;" \
  -H "Content-Type: application/json" \
  -d '{ "all_sessions": false }'

<span class="comment"># Logout everywhere (revoke ALL sessions)</span>
curl -X POST http://localhost:3000/api/auth/logout \
  -H "Authorization: Bearer &lt;access_token&gt;" \
  -H "Content-Type: application/json" \
  -d '{ "all_sessions": true }'</code></pre>

                <h3>Configuration</h3>
                <p>All security features are configured via <code>SecurityConfig</code> and environment variables:</p>
<pre><code><span class="kw">use</span> chopin_core::config::{Config, SecurityConfig};

<span class="comment">// All features enabled by default</span>
<span class="kw">let</span> config = Config::from_env()?;
assert!(config.security.enable_2fa);
assert!(config.security.enable_rate_limit);
assert!(config.security.enable_refresh_tokens);

<span class="comment">// Override programmatically</span>
<span class="kw">let mut</span> config = Config::from_env()?;
config.security.enable_2fa = <span class="kw">false</span>;
config.security.min_password_length = <span class="num">16</span>;</code></pre>

                <h3>Testing with Security</h3>
                <p><code>TestApp::new()</code> disables all security features for backward compatibility. Use <code>TestApp::new_secure()</code> to test with security enabled:</p>
<pre><code><span class="kw">use</span> chopin_core::testing::TestApp;

<span class="comment">// Without security (backward compatible)</span>
<span class="kw">let</span> app = TestApp::new().<span class="kw">await</span>;

<span class="comment">// With all security features enabled</span>
<span class="kw">let</span> app = TestApp::new_secure().<span class="kw">await</span>;</code></pre>

                <h3>Database Tables</h3>
                <p>Security features use 4 additional tables, auto-created by the migration:</p>
                <table class="config-table">
                    <thead>
                        <tr><th>Table</th><th>Purpose</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>refresh_tokens</code></td><td>Stores hashed refresh tokens with rotation tracking</td></tr>
                        <tr><td><code>sessions</code></td><td>Server-side session management / token blacklist</td></tr>
                        <tr><td><code>security_tokens</code></td><td>Password reset and email verification tokens</td></tr>
                        <tr><td><code>login_events</code></td><td>Audit log with IP, user agent, success/failure</td></tr>
                    </tbody>
                </table>
            </section>

            <!-- 9. Roles & Permissions -->
            <section id="roles" class="tutorial-section">
                <div class="section-number">09</div>
                <h2>Roles & Permissions</h2>
                <p>Chopin has a simple but effective <strong>hierarchical role system</strong>. Higher roles inherit all permissions of lower roles.</p>

                <div class="role-hierarchy">
                    <div class="role-card">
                        <div class="role-level">Level 0</div>
                        <h4>User</h4>
                        <p>Default role for new accounts</p>
                    </div>
                    <div class="role-arrow">&rarr;</div>
                    <div class="role-card">
                        <div class="role-level">Level 1</div>
                        <h4>Admin</h4>
                        <p>Can do everything User can + admin actions</p>
                    </div>
                    <div class="role-arrow">&rarr;</div>
                    <div class="role-card">
                        <div class="role-level">Level 2</div>
                        <h4>Superuser</h4>
                        <p>Full access to everything</p>
                    </div>
                </div>

                <h3>Protect routes by role</h3>
<pre><code><span class="kw">use</span> chopin_core::extractors::AuthUserWithRole;
<span class="kw">use</span> chopin_core::models::user::Role;

<span class="comment">// Only admins and superusers can access this</span>
<span class="kw">pub async fn</span> <span class="fn">admin_dashboard</span>(
    user: AuthUserWithRole&lt;{ Role::Admin <span class="kw">as</span> u8 }&gt;,
) -> <span class="kw">impl</span> IntoResponse {
    <span class="comment">// user.user_id, user.email, user.role are available</span>
    chopin_core::Json(json!({ "message": "Welcome, admin!" }))
}

<span class="comment">// Or use the require_role middleware on a group of routes</span>
<span class="kw">use</span> chopin_core::extractors::require_role;

<span class="kw">fn</span> <span class="fn">admin_routes</span>() -> Router&lt;AppState&gt; {
    Router::new()
        .route(<span class="str">"/api/admin/users"</span>, get(list_users))
        .route(<span class="str">"/api/admin/stats"</span>, get(admin_stats))
        .layer(chopin_core::middleware::from_fn(require_role::&lt;{ Role::Admin <span class="kw">as</span> u8 }&gt;))
}</code></pre>

                <h3>Create a superuser</h3>
<pre><code><span class="comment"># Via CLI</span>
chopin createsuperuser</code></pre>
            </section>

            <!-- 10. Extractors -->
            <section id="extractors" class="tutorial-section">
                <div class="section-number">10</div>
                <h2>Extractors</h2>
                <p>Extractors are Axum's way of parsing request data. Chopin provides custom extractors for common patterns.</p>

                <h3>AuthUser &mdash; JWT authentication</h3>
<pre><code><span class="kw">use</span> chopin_core::extractors::AuthUser;

<span class="comment">// Automatically validates the Bearer token from Authorization header</span>
<span class="kw">pub async fn</span> <span class="fn">get_profile</span>(user: AuthUser) -> <span class="kw">impl</span> IntoResponse {
    <span class="comment">// user.user_id: String (UUID)</span>
    <span class="comment">// user.email: String</span>
    <span class="comment">// user.role: String</span>
    chopin_core::Json(json!({
        "id": user.user_id,
        "email": user.email,
        "role": user.role,
    }))
}</code></pre>

                <h3>Json &mdash; SIMD-accelerated body parsing</h3>
<pre><code><span class="kw">use</span> chopin_core::extractors::Json;

<span class="comment">// When `perf` feature is enabled, uses sonic-rs (SIMD)</span>
<span class="comment">// Otherwise falls back to serde_json</span>
<span class="kw">pub async fn</span> <span class="fn">create_item</span>(
    Json(payload): Json&lt;CreateItemRequest&gt;,
) -> <span class="kw">impl</span> IntoResponse {
    <span class="comment">// payload is deserialized from request body</span>
}</code></pre>

                <h3>Pagination &mdash; query parameter extraction</h3>
<pre><code><span class="kw">use</span> chopin_core::extractors::Pagination;

<span class="comment">// GET /api/posts?page=2&per_page=20</span>
<span class="kw">pub async fn</span> <span class="fn">list_items</span>(
    Query(pagination): Query&lt;Pagination&gt;,
) {
    <span class="kw">let</span> p = pagination.clamped(); <span class="comment">// Enforces min/max</span>
    <span class="comment">// p.page: clamped to 1..10000</span>
    <span class="comment">// p.per_page: clamped to 1..100</span>
    <span class="comment">// p.offset: computed as (page - 1) * per_page</span>
    <span class="comment">// p.limit: same as per_page</span>
}</code></pre>
            </section>

            <!-- 11. Pagination -->
            <section id="pagination" class="tutorial-section">
                <div class="section-number">11</div>
                <h2>Pagination</h2>
                <p>Chopin provides a complete pagination system with clamped values and a standardized response format.</p>

<pre><code><span class="kw">use</span> chopin_core::extractors::{Pagination, PaginatedResponse};

<span class="kw">pub async fn</span> <span class="fn">list_posts</span>(
    State(state): State&lt;AppState&gt;,
    Query(pagination): Query&lt;Pagination&gt;,
) -> chopin_core::Json&lt;PaginatedResponse&lt;PostResponse&gt;&gt; {
    <span class="kw">let</span> p = pagination.clamped();

    <span class="comment">// Count total items</span>
    <span class="kw">let</span> total = Post::find().count(&state.db).<span class="kw">await</span>.unwrap_or(<span class="num">0</span>);

    <span class="comment">// Fetch page</span>
    <span class="kw">let</span> items = Post::find()
        .offset(p.offset)
        .limit(p.limit)
        .all(&state.db).<span class="kw">await</span>.unwrap_or_default()
        .into_iter().map(PostResponse::from).collect();

    chopin_core::Json(PaginatedResponse::new(items, total, p.page, p.per_page))
}

<span class="comment">// Response format:</span>
<span class="comment">// {</span>
<span class="comment">//   "data": [...],</span>
<span class="comment">//   "pagination": {</span>
<span class="comment">//     "page": 1,</span>
<span class="comment">//     "per_page": 20,</span>
<span class="comment">//     "total": 150,</span>
<span class="comment">//     "total_pages": 8</span>
<span class="comment">//   }</span>
<span class="comment">// }</span></code></pre>
            </section>

            <!-- 12. Error Handling -->
            <section id="error-handling" class="tutorial-section">
                <div class="section-number">12</div>
                <h2>Error Handling</h2>
                <p>Chopin provides a unified error type that automatically maps to HTTP status codes and JSON responses.</p>

<pre><code><span class="kw">use</span> chopin_core::error::{ChopinError, FieldError};

<span class="comment">// Each variant maps to an HTTP status code</span>
ChopinError::NotFound(<span class="str">"User not found"</span>.into())         <span class="comment">// 404</span>
ChopinError::BadRequest(<span class="str">"Invalid input"</span>.into())         <span class="comment">// 400</span>
ChopinError::Unauthorized(<span class="str">"Invalid token"</span>.into())       <span class="comment">// 401</span>
ChopinError::Forbidden(<span class="str">"Not allowed"</span>.into())            <span class="comment">// 403</span>
ChopinError::Conflict(<span class="str">"Email already exists"</span>.into())   <span class="comment">// 409</span>
ChopinError::Internal(<span class="str">"Something broke"</span>.into())        <span class="comment">// 500</span>

<span class="comment">// All errors produce consistent JSON:</span>
<span class="comment">// { "success": false, "error": "User not found" }</span></code></pre>

                <h3>Field-level validation errors</h3>
<pre><code><span class="comment">// Return multiple field errors at once</span>
<span class="kw">let</span> errors = <span class="kw">vec!</span>[
    FieldError::new(<span class="str">"email"</span>, <span class="str">"must be a valid email address"</span>),
    FieldError::new(<span class="str">"password"</span>, <span class="str">"must be at least 8 characters"</span>),
];
<span class="kw">return</span> Err(ChopinError::ValidationErrors(errors));

<span class="comment">// Response (422):</span>
<span class="comment">// {</span>
<span class="comment">//   "success": false,</span>
<span class="comment">//   "error": "Validation failed",</span>
<span class="comment">//   "fields": [</span>
<span class="comment">//     { "field": "email", "message": "must be a valid email address" },</span>
<span class="comment">//     { "field": "password", "message": "must be at least 8 characters" }</span>
<span class="comment">//   ]</span>
<span class="comment">// }</span></code></pre>

                <h3>Using in handlers</h3>
<pre><code><span class="kw">use</span> chopin_core::error::ChopinError;
<span class="kw">use</span> chopin_core::response::ApiResponse;

<span class="kw">pub async fn</span> <span class="fn">get_post</span>(
    State(state): State&lt;AppState&gt;,
    Path(id): Path&lt;<span class="type">i32</span>&gt;,
) -> <span class="type">Result</span>&lt;chopin_core::Json&lt;ApiResponse&lt;PostResponse&gt;&gt;, ChopinError&gt; {
    <span class="kw">let</span> post = Post::find_by_id(id)
        .one(&state.db).<span class="kw">await</span>
        .map_err(|e| ChopinError::Database(e.to_string()))?
        .ok_or_else(|| ChopinError::NotFound(<span class="kw">format!</span>(<span class="str">"Post {} not found"</span>, id)))?;

    <span class="type">Ok</span>(chopin_core::Json(ApiResponse::success(PostResponse::from(post))))
}</code></pre>
            </section>

            <!-- 13. OpenAPI Docs -->
            <section id="openapi" class="tutorial-section">
                <div class="section-number">13</div>
                <h2>API Documentation (OpenAPI)</h2>
                <p>Chopin provides <strong>first-class OpenAPI 3.1 documentation</strong> with the beautiful <strong>Scalar UI</strong>, following the same pattern as Axum + utoipa. You get built-in auth endpoint docs out of the box, and can add your own endpoints with simple annotations &mdash; no extra crates needed.</p>

                <div class="callout">
                    <i data-lucide="external-link" class="inline-icon"></i>
                    <div>
                        Visit <code>http://localhost:3000/api-docs</code> after starting your server to see the interactive API documentation. The raw OpenAPI JSON spec is at <code>/api-docs/openapi.json</code>.
                    </div>
                </div>

                <h3>What you get for free</h3>
                <p>Every Chopin app includes automatic API docs for the built-in auth endpoints. Just run <code>App::new().await?.run().await?</code> and you have:</p>
                <div class="endpoint-table">
                    <table>
                        <thead>
                            <tr><th>Method</th><th>Path</th><th>Documented?</th></tr>
                        </thead>
                        <tbody>
                            <tr><td><span class="method post">POST</span></td><td><code>/api/auth/signup</code></td><td>Auto-documented with request/response schemas</td></tr>
                            <tr><td><span class="method post">POST</span></td><td><code>/api/auth/login</code></td><td>Auto-documented with request/response schemas</td></tr>
                            <tr><td><span class="method get">GET</span></td><td><code>/api-docs</code></td><td>Scalar interactive UI</td></tr>
                            <tr><td><span class="method get">GET</span></td><td><code>/api-docs/openapi.json</code></td><td>Raw OpenAPI 3.1 spec</td></tr>
                        </tbody>
                    </table>
                </div>

                <h3>Step 1: Define your request &amp; response types</h3>
                <p>Add <code>#[derive(ToSchema)]</code> to any struct you want in your API docs. Chopin re-exports everything from <code>utoipa</code> &mdash; you never need to add <code>utoipa</code> to your Cargo.toml.</p>
<pre><code><span class="kw">use</span> chopin_core::prelude::*;

<span class="doc">/// Request body for creating a post.</span>
<span class="attr">#[derive(Debug, Deserialize, ToSchema)]</span>
<span class="kw">pub struct</span> <span class="type">CreatePostRequest</span> {
    <span class="doc">/// Post title (required, 1-200 characters)</span>
    <span class="kw">pub</span> title: <span class="type">String</span>,
    <span class="doc">/// Post body content in markdown (required)</span>
    <span class="kw">pub</span> body: <span class="type">String</span>,
    <span class="doc">/// Optional tags for categorization</span>
    <span class="kw">pub</span> tags: Option&lt;Vec&lt;<span class="type">String</span>&gt;&gt;,
}

<span class="doc">/// Response body for a post.</span>
<span class="attr">#[derive(Debug, Serialize, Deserialize, ToSchema)]</span>
<span class="kw">pub struct</span> <span class="type">PostResponse</span> {
    <span class="kw">pub</span> id: <span class="type">i32</span>,
    <span class="kw">pub</span> title: <span class="type">String</span>,
    <span class="kw">pub</span> body: <span class="type">String</span>,
    <span class="kw">pub</span> published: <span class="type">bool</span>,
    <span class="kw">pub</span> created_at: <span class="type">String</span>,
}

<span class="doc">/// Request body for updating a post.</span>
<span class="attr">#[derive(Debug, Deserialize, ToSchema)]</span>
<span class="kw">pub struct</span> <span class="type">UpdatePostRequest</span> {
    <span class="doc">/// Updated title (optional)</span>
    <span class="kw">pub</span> title: Option&lt;<span class="type">String</span>&gt;,
    <span class="doc">/// Updated body (optional)</span>
    <span class="kw">pub</span> body: Option&lt;<span class="type">String</span>&gt;,
    <span class="doc">/// Publish or unpublish (optional)</span>
    <span class="kw">pub</span> published: Option&lt;<span class="type">bool</span>&gt;,
}</code></pre>

                <div class="callout">
                    <i data-lucide="info" class="inline-icon"></i>
                    <div>
                        <strong>Tip:</strong> Use <code>///</code> doc comments on fields &mdash; they appear as field descriptions in the Scalar UI. This is the best way to document your API for frontend developers.
                    </div>
                </div>

                <h3>Step 2: Annotate your handlers</h3>
                <p>Add <code>#[utoipa::path(...)]</code> to each handler function. This is the same pattern used in Axum &mdash; define the HTTP method, path, request body, and all possible responses.</p>
<pre><code><span class="kw">use</span> chopin_core::prelude::*;
<span class="kw">use</span> chopin_core::response::ApiResponse;
<span class="kw">use</span> chopin_core::extractors::{Json, Pagination, Path, Query, State};

<span class="doc">/// List all posts with pagination.</span>
<span class="attr">#[utoipa::path(
    get,
    path = "/api/posts",
    tag = "posts",
    params(Pagination),
    responses(
        (status = 200, description = "Paginated list of posts",
         body = ApiResponse&lt;Vec&lt;PostResponse&gt;&gt;)
    )
)]</span>
<span class="kw">pub async fn</span> <span class="fn">list_posts</span>(
    State(state): State&lt;AppState&gt;,
    Query(pagination): Query&lt;Pagination&gt;,
) -> <span class="type">Result</span>&lt;Json&lt;ApiResponse&lt;Vec&lt;PostResponse&gt;&gt;&gt;, StatusCode&gt; {
    <span class="comment">// ...handler logic...</span>
}

<span class="doc">/// Create a new post.</span>
<span class="attr">#[utoipa::path(
    post,
    path = "/api/posts",
    tag = "posts",
    request_body = CreatePostRequest,
    responses(
        (status = 201, description = "Post created successfully",
         body = ApiResponse&lt;PostResponse&gt;),
        (status = 400, description = "Validation error"),
        (status = 401, description = "Unauthorized ‚Äî missing or invalid token")
    ),
    security(("bearer_auth" = []))
)]</span>
<span class="kw">pub async fn</span> <span class="fn">create_post</span>(
    State(state): State&lt;AppState&gt;,
    Json(payload): Json&lt;CreatePostRequest&gt;,
) -> <span class="type">Result</span>&lt;(StatusCode, Json&lt;ApiResponse&lt;PostResponse&gt;&gt;), StatusCode&gt; {
    <span class="comment">// ...handler logic...</span>
}

<span class="doc">/// Get a single post by ID.</span>
<span class="attr">#[utoipa::path(
    get,
    path = "/api/posts/{id}",
    tag = "posts",
    params(
        ("id" = i32, Path, description = "Post ID")
    ),
    responses(
        (status = 200, description = "Post found", body = ApiResponse&lt;PostResponse&gt;),
        (status = 404, description = "Post not found")
    )
)]</span>
<span class="kw">pub async fn</span> <span class="fn">get_post</span>(
    State(state): State&lt;AppState&gt;,
    Path(id): Path&lt;<span class="type">i32</span>&gt;,
) -> <span class="type">Result</span>&lt;Json&lt;ApiResponse&lt;PostResponse&gt;&gt;, StatusCode&gt; {
    <span class="comment">// ...handler logic...</span>
}

<span class="doc">/// Update an existing post.</span>
<span class="attr">#[utoipa::path(
    put,
    path = "/api/posts/{id}",
    tag = "posts",
    params(("id" = i32, Path, description = "Post ID")),
    request_body = UpdatePostRequest,
    responses(
        (status = 200, description = "Post updated", body = ApiResponse&lt;PostResponse&gt;),
        (status = 404, description = "Post not found"),
        (status = 401, description = "Unauthorized")
    ),
    security(("bearer_auth" = []))
)]</span>
<span class="kw">pub async fn</span> <span class="fn">update_post</span>(...) { <span class="comment">/* ... */</span> }

<span class="doc">/// Delete a post by ID.</span>
<span class="attr">#[utoipa::path(
    delete,
    path = "/api/posts/{id}",
    tag = "posts",
    params(("id" = i32, Path, description = "Post ID")),
    responses(
        (status = 200, description = "Post deleted"),
        (status = 404, description = "Post not found"),
        (status = 401, description = "Unauthorized")
    ),
    security(("bearer_auth" = []))
)]</span>
<span class="kw">pub async fn</span> <span class="fn">delete_post</span>(...) { <span class="comment">/* ... */</span> }</code></pre>

                <h3>Step 3: Create your OpenAPI doc struct</h3>
                <p>Define a struct with <code>#[derive(OpenApi)]</code> that lists all your documented paths and schemas. Use <code>SecurityAddon</code> (re-exported by Chopin) to add JWT Bearer auth.</p>
<pre><code><span class="kw">use</span> chopin_core::prelude::*;

<span class="attr">#[derive(OpenApi)]</span>
<span class="attr">#[openapi(
    info(
        title = "My Blog API",
        version = "1.0.0",
        description = "A blog API built with Chopin"
    ),
    paths(
        controllers::posts::list_posts,
        controllers::posts::create_post,
        controllers::posts::get_post,
        controllers::posts::update_post,
        controllers::posts::delete_post,
    ),
    components(
        schemas(
            PostResponse,
            CreatePostRequest,
            UpdatePostRequest,
        )
    ),
    tags(
        (name = "posts", description = "Blog post management")
    ),
    security(
        ("bearer_auth" = [])
    ),
    modifiers(&SecurityAddon)
)]</span>
<span class="kw">pub struct</span> <span class="type">MyApiDoc</span>;</code></pre>

                <h3>Step 4: Mount your docs on the App</h3>
                <p>Pass your OpenAPI spec to <code>App::api_docs()</code>. Chopin automatically <strong>merges</strong> your endpoints with the built-in auth docs, so everything appears in one place.</p>
<pre><code><span class="kw">use</span> chopin_core::prelude::*;

<span class="attr">#[tokio::main]</span>
<span class="kw">async fn</span> <span class="fn">main</span>() -> <span class="type">Result</span>&lt;(), Box&lt;<span class="kw">dyn</span> std::error::Error&gt;&gt; {
    tracing_subscriber::fmt::init();

    <span class="kw">let</span> app = App::new().<span class="kw">await</span>?
        .api_docs(MyApiDoc::openapi());  <span class="comment">// ‚Üê your docs merged with built-in auth docs</span>

    app.run().<span class="kw">await</span>?;
    <span class="type">Ok</span>(())
}</code></pre>
                <p>Now <code>/api-docs</code> shows <strong>all</strong> endpoints: your posts CRUD + the built-in auth signup/login.</p>

                <h3>Customize the docs URL</h3>
                <p>Change where the docs are served with <code>api_docs_url()</code>:</p>
<pre><code><span class="kw">let</span> app = App::new().<span class="kw">await</span>?
    .api_docs_url(<span class="str">"/docs"</span>)               <span class="comment">// Scalar UI at /docs</span>
    .api_docs(MyApiDoc::openapi());      <span class="comment">// openapi.json at /docs/openapi.json</span></code></pre>

                <h3>Complete example: full CRUD with API docs</h3>
                <p>Here&rsquo;s a complete working example showing the full pattern from model to API docs:</p>
<pre><code><span class="comment">// src/main.rs</span>
<span class="kw">use</span> chopin_core::prelude::*;
<span class="kw">use</span> chopin_core::response::ApiResponse;
<span class="kw">use</span> chopin_core::extractors::{Json, Pagination, Path, Query, State};
<span class="kw">use</span> chopin_core::error::ChopinError;

<span class="comment">// ‚îÄ‚îÄ Request / Response types with ToSchema ‚îÄ‚îÄ</span>

<span class="attr">#[derive(Debug, Deserialize, ToSchema)]</span>
<span class="kw">pub struct</span> <span class="type">CreatePostRequest</span> {
    <span class="doc">/// Post title (1-200 characters)</span>
    <span class="kw">pub</span> title: <span class="type">String</span>,
    <span class="doc">/// Post body in markdown</span>
    <span class="kw">pub</span> body: <span class="type">String</span>,
}

<span class="attr">#[derive(Debug, Serialize, Deserialize, ToSchema)]</span>
<span class="kw">pub struct</span> <span class="type">PostResponse</span> {
    <span class="kw">pub</span> id: <span class="type">i32</span>,
    <span class="kw">pub</span> title: <span class="type">String</span>,
    <span class="kw">pub</span> body: <span class="type">String</span>,
    <span class="kw">pub</span> published: <span class="type">bool</span>,
}

<span class="comment">// ‚îÄ‚îÄ Handlers with #[utoipa::path] annotations ‚îÄ‚îÄ</span>

<span class="doc">/// List all posts.</span>
<span class="attr">#[utoipa::path(
    get,
    path = "/api/posts",
    tag = "posts",
    params(Pagination),
    responses(
        (status = 200, description = "List of posts",
         body = ApiResponse&lt;Vec&lt;PostResponse&gt;&gt;)
    )
)]</span>
<span class="kw">pub async fn</span> <span class="fn">list_posts</span>() -> Json&lt;ApiResponse&lt;Vec&lt;PostResponse&gt;&gt;&gt; {
    Json(ApiResponse::success(<span class="kw">vec!</span>[]))
}

<span class="doc">/// Create a new post (requires auth).</span>
<span class="attr">#[utoipa::path(
    post,
    path = "/api/posts",
    tag = "posts",
    request_body = CreatePostRequest,
    responses(
        (status = 201, description = "Post created",
         body = ApiResponse&lt;PostResponse&gt;),
        (status = 401, description = "Unauthorized")
    ),
    security(("bearer_auth" = []))
)]</span>
<span class="kw">pub async fn</span> <span class="fn">create_post</span>(
    Json(payload): Json&lt;CreatePostRequest&gt;,
) -> (StatusCode, Json&lt;ApiResponse&lt;PostResponse&gt;&gt;) {
    <span class="kw">let</span> post = PostResponse {
        id: <span class="num">1</span>,
        title: payload.title,
        body: payload.body,
        published: <span class="kw">false</span>,
    };
    (StatusCode::CREATED, Json(ApiResponse::success(post)))
}

<span class="comment">// ‚îÄ‚îÄ OpenAPI doc struct ‚îÄ‚îÄ</span>

<span class="attr">#[derive(OpenApi)]</span>
<span class="attr">#[openapi(
    info(title = "My Blog API", version = "1.0.0"),
    paths(list_posts, create_post),
    components(schemas(PostResponse, CreatePostRequest)),
    tags((name = "posts", description = "Blog posts")),
    security(("bearer_auth" = [])),
    modifiers(&SecurityAddon)
)]</span>
<span class="kw">struct</span> <span class="type">MyApiDoc</span>;

<span class="comment">// ‚îÄ‚îÄ App startup ‚îÄ‚îÄ</span>

<span class="attr">#[tokio::main]</span>
<span class="kw">async fn</span> <span class="fn">main</span>() -> <span class="type">Result</span>&lt;(), Box&lt;<span class="kw">dyn</span> std::error::Error&gt;&gt; {
    tracing_subscriber::fmt::init();

    <span class="kw">let</span> app = App::new().<span class="kw">await</span>?
        .api_docs(MyApiDoc::openapi());

    app.run().<span class="kw">await</span>?;
    <span class="type">Ok</span>(())
}

<span class="comment">// üéπ Chopin is running</span>
<span class="comment">//    ‚Üí Server:    http://127.0.0.1:3000</span>
<span class="comment">//    ‚Üí API docs:  http://127.0.0.1:3000/api-docs</span>
<span class="comment">//</span>
<span class="comment">// /api-docs now shows:</span>
<span class="comment">//   auth   ‚Üí POST /api/auth/signup, POST /api/auth/login (built-in)</span>
<span class="comment">//   posts  ‚Üí GET /api/posts, POST /api/posts (your endpoints)</span></code></pre>

                <h3>Advanced: build a Router with custom API docs (Axum-style)</h3>
                <p>If you prefer full control (like raw Axum), skip <code>App::api_docs()</code> and build your router manually. Chopin re-exports <code>Scalar</code> and <code>Servable</code> so you don&rsquo;t need extra crate dependencies.</p>
<pre><code><span class="kw">use</span> chopin_core::prelude::*;
<span class="kw">use</span> chopin_core::{Router, serve};

<span class="attr">#[derive(OpenApi)]</span>
<span class="attr">#[openapi(
    info(title = "Custom API", version = "2.0.0"),
    paths(list_posts, create_post, get_post, update_post, delete_post),
    components(schemas(PostResponse, CreatePostRequest, UpdatePostRequest)),
    tags(
        (name = "posts", description = "Post management"),
        (name = "admin", description = "Admin-only operations")
    ),
    security(("bearer_auth" = [])),
    modifiers(&SecurityAddon)
)]</span>
<span class="kw">struct</span> <span class="type">MyApiDoc</span>;

<span class="attr">#[tokio::main]</span>
<span class="kw">async fn</span> <span class="fn">main</span>() -> <span class="type">Result</span>&lt;(), Box&lt;<span class="kw">dyn</span> std::error::Error&gt;&gt; {
    <span class="comment">// Build router exactly like you would in Axum</span>
    <span class="kw">let</span> app = Router::new()
        .merge(post_routes())
        <span class="comment">// Mount Scalar UI at /docs</span>
        .merge(Scalar::with_url(<span class="str">"/docs"</span>, MyApiDoc::openapi()))
        <span class="comment">// Serve raw OpenAPI JSON spec</span>
        .route(<span class="str">"/docs/openapi.json"</span>, get(|| <span class="kw">async</span> {
            chopin_core::extractors::Json(MyApiDoc::openapi())
        }));

    <span class="kw">let</span> listener = tokio::net::TcpListener::bind(<span class="str">"0.0.0.0:3000"</span>).<span class="kw">await</span>?;
    serve(listener, app).<span class="kw">await</span>?;
    <span class="type">Ok</span>(())
}</code></pre>

                <h3>Merging multiple OpenAPI specs</h3>
                <p>Use <code>merge_openapi()</code> to combine specs from different modules or the built-in auth docs:</p>
<pre><code><span class="kw">use</span> chopin_core::openapi::{ApiDoc, merge_openapi};
<span class="kw">use</span> chopin_core::prelude::*;

<span class="comment">// Your docs</span>
<span class="attr">#[derive(OpenApi)]</span>
<span class="attr">#[openapi(
    paths(list_posts, create_post),
    components(schemas(PostResponse, CreatePostRequest)),
    tags((name = "posts", description = "Posts"))
)]</span>
<span class="kw">struct</span> <span class="type">PostDocs</span>;

<span class="attr">#[derive(OpenApi)]</span>
<span class="attr">#[openapi(
    paths(list_users, get_user),
    components(schemas(UserProfileResponse)),
    tags((name = "users", description = "User profiles"))
)]</span>
<span class="kw">struct</span> <span class="type">UserDocs</span>;

<span class="comment">// Merge all three: built-in auth + posts + users</span>
<span class="kw">let</span> combined = merge_openapi(
    merge_openapi(ApiDoc::openapi(), PostDocs::openapi()),
    UserDocs::openapi(),
);

<span class="comment">// Use with Scalar or App</span>
<span class="kw">let</span> app = App::new().<span class="kw">await</span>?
    .api_docs(combined);</code></pre>

                <h3>#[utoipa::path] attribute reference</h3>
                <p>Here&rsquo;s every option you can use in the path annotation:</p>
                <div class="endpoint-table">
                    <table>
                        <thead>
                            <tr><th>Attribute</th><th>Description</th><th>Example</th></tr>
                        </thead>
                        <tbody>
                            <tr><td><code>get</code> / <code>post</code> / <code>put</code> / <code>delete</code> / <code>patch</code></td><td>HTTP method</td><td><code>#[utoipa::path(get, ...)]</code></td></tr>
                            <tr><td><code>path</code></td><td>URL path (must match your route)</td><td><code>path = "/api/posts/{id}"</code></td></tr>
                            <tr><td><code>tag</code></td><td>Group endpoints in the UI</td><td><code>tag = "posts"</code></td></tr>
                            <tr><td><code>request_body</code></td><td>Request body type (must derive <code>ToSchema</code>)</td><td><code>request_body = CreatePostRequest</code></td></tr>
                            <tr><td><code>params(...)</code></td><td>Path/query parameters</td><td><code>params(("id" = i32, Path, description = "Post ID"))</code></td></tr>
                            <tr><td><code>responses(...)</code></td><td>List of possible responses</td><td><code>(status = 200, description = "OK", body = PostResponse)</code></td></tr>
                            <tr><td><code>security(...)</code></td><td>Auth requirements for this endpoint</td><td><code>security(("bearer_auth" = []))</code></td></tr>
                            <tr><td><code>operation_id</code></td><td>Custom operation ID</td><td><code>operation_id = "listPosts"</code></td></tr>
                            <tr><td><code>summary</code></td><td>Short summary (uses doc comment by default)</td><td><code>summary = "List all posts"</code></td></tr>
                            <tr><td><code>description</code></td><td>Long description</td><td><code>description = "Returns paginated posts"</code></td></tr>
                        </tbody>
                    </table>
                </div>

                <h3>#[derive(ToSchema)] tips</h3>
<pre><code><span class="comment">// Rename fields in the schema</span>
<span class="attr">#[derive(Serialize, ToSchema)]</span>
<span class="attr">#[schema(rename_all = "camelCase")]</span>
<span class="kw">pub struct</span> <span class="type">PostResponse</span> {
    <span class="kw">pub</span> created_at: <span class="type">String</span>,  <span class="comment">// ‚Üí "createdAt" in docs</span>
}

<span class="comment">// Add examples to fields</span>
<span class="attr">#[derive(Deserialize, ToSchema)]</span>
<span class="kw">pub struct</span> <span class="type">CreatePostRequest</span> {
    <span class="attr">#[schema(example = "My First Post")]</span>
    <span class="kw">pub</span> title: <span class="type">String</span>,

    <span class="attr">#[schema(example = "Hello world! This is my first blog post.")]</span>
    <span class="kw">pub</span> body: <span class="type">String</span>,

    <span class="attr">#[schema(minimum = 0, maximum = 10)]</span>
    <span class="kw">pub</span> priority: Option&lt;<span class="type">i32</span>&gt;,
}

<span class="comment">// Enum schemas</span>
<span class="attr">#[derive(Serialize, Deserialize, ToSchema)]</span>
<span class="kw">pub enum</span> <span class="type">PostStatus</span> {
    Draft,
    Published,
    Archived,
}

<span class="comment">// Nested schemas ‚Äî inner types must also derive ToSchema</span>
<span class="attr">#[derive(Serialize, ToSchema)]</span>
<span class="kw">pub struct</span> <span class="type">PostWithAuthor</span> {
    <span class="kw">pub</span> post: PostResponse,      <span class="comment">// must derive ToSchema</span>
    <span class="kw">pub</span> author: AuthorResponse,   <span class="comment">// must derive ToSchema</span>
}</code></pre>

                <h3>Paginated query parameters</h3>
                <p>Chopin's <code>Pagination</code> type already implements <code>IntoParams</code> for utoipa, so you can document pagination queries automatically:</p>
<pre><code><span class="attr">#[utoipa::path(
    get,
    path = "/api/posts",
    tag = "posts",
    params(Pagination),   <span class="comment">// ‚Üê adds page &amp; per_page query params to docs</span>
    responses(
        (status = 200, description = "Paginated posts",
         body = ApiResponse&lt;Vec&lt;PostResponse&gt;&gt;)
    )
)]</span>
<span class="kw">pub async fn</span> <span class="fn">list_posts</span>(
    Query(pagination): Query&lt;Pagination&gt;,
) -> Json&lt;ApiResponse&lt;Vec&lt;PostResponse&gt;&gt;&gt; {
    <span class="comment">// Scalar UI shows: ?page=1&amp;per_page=20</span>
}</code></pre>

                <h3>Protecting endpoints in docs</h3>
                <p>Add <code>security(("bearer_auth" = []))</code> to show a lock icon on endpoints that require authentication. Use <code>SecurityAddon</code> as a modifier to register the scheme:</p>
<pre><code><span class="comment">// Per-endpoint security (lock icon in Scalar UI)</span>
<span class="attr">#[utoipa::path(
    delete,
    path = "/api/posts/{id}",
    tag = "posts",
    security(("bearer_auth" = [])),  <span class="comment">// ‚Üê this endpoint requires JWT</span>
    responses((status = 200, description = "Deleted"))
)]</span>
<span class="kw">pub async fn</span> <span class="fn">delete_post</span>(...) { }

<span class="comment">// Global security in the OpenAPI struct</span>
<span class="attr">#[derive(OpenApi)]</span>
<span class="attr">#[openapi(
    paths(delete_post, list_posts),
    security(("bearer_auth" = [])),  <span class="comment">// ‚Üê all endpoints require JWT by default</span>
    modifiers(&SecurityAddon)         <span class="comment">// ‚Üê registers the Bearer scheme</span>
)]</span>
<span class="kw">struct</span> <span class="type">ApiDoc</span>;</code></pre>

                <h3>Export OpenAPI spec</h3>
<pre><code><span class="comment"># Export to JSON file</span>
chopin docs export --format json --output openapi.json

<span class="comment"># Export as YAML</span>
chopin docs export --format yaml --output openapi.yaml

<span class="comment"># Or fetch it from a running server</span>
curl http://localhost:3000/api-docs/openapi.json > openapi.json</code></pre>

                <h3>Re-exported types cheat sheet</h3>
                <p>Everything you need is available from <code>chopin_core</code> &mdash; no need to add <code>utoipa</code> or <code>utoipa-scalar</code> to your Cargo.toml:</p>
                <div class="endpoint-table">
                    <table>
                        <thead>
                            <tr><th>Import</th><th>What it is</th></tr>
                        </thead>
                        <tbody>
                            <tr><td><code>chopin_core::OpenApi</code></td><td>The <code>#[derive(OpenApi)]</code> derive macro</td></tr>
                            <tr><td><code>chopin_core::ToSchema</code></td><td>The <code>#[derive(ToSchema)]</code> derive macro</td></tr>
                            <tr><td><code>chopin_core::Scalar</code></td><td>Scalar UI component (for custom routers)</td></tr>
                            <tr><td><code>chopin_core::Servable</code></td><td>Trait for mounting Scalar on a Router</td></tr>
                            <tr><td><code>chopin_core::openapi::SecurityAddon</code></td><td>JWT Bearer modifier (use in <code>modifiers(&SecurityAddon)</code>)</td></tr>
                            <tr><td><code>chopin_core::openapi::ApiDoc</code></td><td>Built-in auth endpoint docs</td></tr>
                            <tr><td><code>chopin_core::openapi::merge_openapi</code></td><td>Merge two OpenAPI specs together</td></tr>
                            <tr><td><code>chopin_core::prelude::*</code></td><td>Includes <code>OpenApi</code>, <code>ToSchema</code>, <code>Scalar</code>, <code>Servable</code>, <code>SecurityAddon</code></td></tr>
                        </tbody>
                    </table>
                </div>

                <div class="tip">
                    <strong>Summary ‚Äî API docs in 4 steps:</strong>
                    <ol>
                        <li><code>#[derive(ToSchema)]</code> on your request/response types</li>
                        <li><code>#[utoipa::path(...)]</code> on your handler functions</li>
                        <li><code>#[derive(OpenApi)]</code> struct listing paths + schemas</li>
                        <li><code>App::new().await?.api_docs(MyApiDoc::openapi())</code></li>
                    </ol>
                    Your endpoints are merged with the built-in auth docs automatically.
                </div>
            </section>

            <!-- 14. Caching -->
            <section id="caching" class="tutorial-section">
                <div class="section-number">14</div>
                <h2>Caching</h2>
                <p>Chopin provides a unified caching API with two backends: <strong>in-memory</strong> (default) and <strong>Redis</strong> (feature-gated). Cache any serializable data with TTL support.</p>

                <h3>In-memory cache (default)</h3>
<pre><code><span class="comment">// CacheService is automatically available via AppState</span>
<span class="comment">// when using App::new()</span>

<span class="kw">use</span> chopin_core::cache::CacheService;

<span class="kw">let</span> cache = CacheService::in_memory();

<span class="comment">// Basic string operations</span>
cache.set(<span class="str">"key"</span>, <span class="str">"value"</span>).<span class="kw">await</span>?;
<span class="kw">let</span> val = cache.get(<span class="str">"key"</span>).<span class="kw">await</span>?;            <span class="comment">// Option&lt;String&gt;</span>

<span class="comment">// With TTL (seconds)</span>
cache.set_with_ttl(<span class="str">"key"</span>, <span class="str">"value"</span>, <span class="num">300</span>).<span class="kw">await</span>?;  <span class="comment">// 5 minutes</span>

<span class="comment">// JSON operations ‚Äî cache any Serialize/Deserialize type</span>
cache.set_json(<span class="str">"post:1"</span>, &post_response).<span class="kw">await</span>?;
<span class="kw">let</span> cached: Option&lt;PostResponse&gt; = cache.get_json(<span class="str">"post:1"</span>).<span class="kw">await</span>?;

<span class="comment">// Other operations</span>
cache.delete(<span class="str">"key"</span>).<span class="kw">await</span>?;
cache.exists(<span class="str">"key"</span>).<span class="kw">await</span>?;                    <span class="comment">// bool</span>
cache.flush().<span class="kw">await</span>?;                            <span class="comment">// Clear all</span></code></pre>

                <h3>Redis cache</h3>
<pre><code><span class="comment"># Enable in Cargo.toml</span>
chopin-core = { version = "0.2", features = ["redis"] }

<span class="comment"># Set in .env</span>
REDIS_URL=redis://127.0.0.1:6379</code></pre>

<pre><code><span class="comment">// Redis backend is used automatically when REDIS_URL is set</span>
<span class="comment">// The API is identical ‚Äî same methods, same types</span>
<span class="kw">let</span> cache = CacheService::redis(<span class="str">"redis://127.0.0.1:6379"</span>).<span class="kw">await</span>?;</code></pre>

                <h3>Caching in handlers</h3>
<pre><code><span class="kw">pub async fn</span> <span class="fn">get_post</span>(
    State(state): State&lt;AppState&gt;,
    Path(id): Path&lt;<span class="type">i32</span>&gt;,
) -> <span class="type">Result</span>&lt;chopin_core::Json&lt;ApiResponse&lt;PostResponse&gt;&gt;, ChopinError&gt; {
    <span class="kw">let</span> cache_key = <span class="kw">format!</span>(<span class="str">"post:{}"</span>, id);

    <span class="comment">// Check cache first</span>
    <span class="kw">if let</span> Some(cache) = &state.cache {
        <span class="kw">if let</span> Ok(Some(cached)) = cache.get_json::&lt;PostResponse&gt;(&cache_key).<span class="kw">await</span> {
            <span class="kw">return</span> <span class="type">Ok</span>(chopin_core::Json(ApiResponse::success(cached)));
        }
    }

    <span class="comment">// Fetch from database</span>
    <span class="kw">let</span> post = Post::find_by_id(id).one(&state.db).<span class="kw">await</span>?
        .ok_or_else(|| ChopinError::NotFound(<span class="str">"Post not found"</span>.into()))?;
    <span class="kw">let</span> response = PostResponse::from(post);

    <span class="comment">// Store in cache for 5 minutes</span>
    <span class="kw">if let</span> Some(cache) = &state.cache {
        <span class="kw">let</span> _ = cache.set_json(&cache_key, &response).<span class="kw">await</span>;
    }

    <span class="type">Ok</span>(chopin_core::Json(ApiResponse::success(response)))
}</code></pre>
            </section>

            <!-- 15. File Uploads -->
            <section id="file-uploads" class="tutorial-section">
                <div class="section-number">15</div>
                <h2>File Uploads</h2>
                <p>Upload files to <strong>local disk</strong> or <strong>S3-compatible storage</strong> (AWS S3, Cloudflare R2, MinIO). Chopin handles multipart parsing, validation, and storage.</p>

                <h3>Local storage</h3>
<pre><code><span class="kw">use</span> chopin_core::storage::{LocalStorage, FileUploadService};
<span class="kw">use</span> chopin_core::extract::Multipart;

<span class="kw">let</span> storage = LocalStorage::new(<span class="str">"./uploads"</span>);
<span class="kw">let</span> upload_service = FileUploadService::new(
    Box::new(storage),
    <span class="num">10</span> * <span class="num">1024</span> * <span class="num">1024</span>,  <span class="comment">// 10MB max size</span>
);

<span class="kw">pub async fn</span> <span class="fn">upload_file</span>(
    <span class="kw">mut</span> multipart: Multipart,
) -> <span class="type">Result</span>&lt;<span class="kw">impl</span> IntoResponse, ChopinError&gt; {
    <span class="comment">// Process single file from multipart form</span>
    <span class="kw">let</span> uploaded = upload_service
        .process_single_upload(&<span class="kw">mut</span> multipart, <span class="str">"file"</span>)
        .<span class="kw">await</span>?;

    <span class="comment">// uploaded.filename: original filename</span>
    <span class="comment">// uploaded.stored_path: "uploads/uuid-filename.ext"</span>
    <span class="comment">// uploaded.content_type: "image/png"</span>
    <span class="comment">// uploaded.size: bytes</span>

    <span class="type">Ok</span>(chopin_core::Json(json!({ "path": uploaded.stored_path })))
}</code></pre>

                <h3>S3 / Cloudflare R2 / MinIO</h3>
<pre><code><span class="comment"># Enable in Cargo.toml</span>
chopin-core = { version = "0.2", features = ["s3"] }

<span class="comment"># Configure in .env</span>
S3_BUCKET=my-bucket
S3_REGION=us-east-1
S3_ACCESS_KEY=AKIA...
S3_SECRET_KEY=...
S3_PUBLIC_URL=https://cdn.example.com

<span class="comment"># For Cloudflare R2</span>
S3_ENDPOINT=https://&lt;account-id&gt;.r2.cloudflarestorage.com

<span class="comment"># For MinIO</span>
S3_ENDPOINT=http://localhost:9000</code></pre>

<pre><code><span class="kw">use</span> chopin_core::storage::S3Storage;
<span class="kw">use</span> chopin_core::config::Config;

<span class="kw">let</span> config = Config::from_env()?;
<span class="kw">let</span> s3 = S3Storage::from_config(&config).<span class="kw">await</span>;

<span class="comment">// Same API as LocalStorage</span>
<span class="kw">let</span> upload_service = FileUploadService::new(
    Box::new(s3),
    config.max_upload_size,
);

<span class="comment">// Files are stored as: {prefix}/{uuid}-{filename}</span>
<span class="comment">// e.g., uploads/550e8400-e29b-41d4-a716-446655440000-photo.jpg</span></code></pre>
            </section>

            <!-- 16. GraphQL -->
            <section id="graphql" class="tutorial-section">
                <div class="section-number">16</div>
                <h2>GraphQL</h2>
                <p>Chopin includes optional GraphQL support via <code>async-graphql</code>. Enable it with the <code>graphql</code> feature flag.</p>

<pre><code><span class="comment"># Cargo.toml</span>
chopin-core = { version = "0.2", features = ["graphql"] }</code></pre>

<pre><code><span class="kw">use</span> async_graphql::{Object, Schema, EmptyMutation, EmptySubscription};
<span class="kw">use</span> chopin_core::graphql::graphql_routes;

<span class="kw">struct</span> <span class="type">QueryRoot</span>;

<span class="attr">#[Object]</span>
<span class="kw">impl</span> <span class="type">QueryRoot</span> {
    <span class="kw">async fn</span> <span class="fn">hello</span>(&self) -> &<span class="type">str</span> {
        <span class="str">"Hello from Chopin GraphQL!"</span>
    }

    <span class="kw">async fn</span> <span class="fn">posts</span>(&self) -> Vec&lt;<span class="type">String</span>&gt; {
        <span class="kw">vec!</span>[<span class="str">"Post 1"</span>.into(), <span class="str">"Post 2"</span>.into()]
    }
}

<span class="comment">// Build schema</span>
<span class="kw">let</span> schema = Schema::build(<span class="type">QueryRoot</span>, EmptyMutation, EmptySubscription)
    .finish();

<span class="comment">// Add to your router ‚Äî provides:</span>
<span class="comment">// POST /graphql ‚Äî endpoint</span>
<span class="comment">// GET /graphql  ‚Äî GraphQL Playground UI</span>
<span class="kw">let</span> graphql = graphql_routes(schema);</code></pre>
            </section>

            <!-- 17. Testing -->
            <section id="testing" class="tutorial-section">
                <div class="section-number">17</div>
                <h2>Testing</h2>
                <p>Chopin provides a built-in test harness with <strong>in-memory SQLite</strong>, a test client, and response assertions. Write integration tests with zero configuration.</p>

                <h3>TestApp &mdash; spin up a test server</h3>
<pre><code><span class="kw">use</span> chopin_core::testing::{TestApp, TestClient};

<span class="attr">#[tokio::test]</span>
<span class="kw">async fn</span> <span class="fn">test_signup_and_login</span>() {
    <span class="comment">// Creates in-memory SQLite DB, runs all migrations</span>
    <span class="kw">let</span> test_app = TestApp::new().<span class="kw">await</span>;
    <span class="kw">let</span> client = test_app.client();

    <span class="comment">// Sign up</span>
    <span class="kw">let</span> res = client.post_json(
        <span class="str">"/api/auth/signup"</span>,
        <span class="str">r#"{"email":"test@example.com","password":"password123","name":"Test"}"#</span>,
    ).<span class="kw">await</span>;

    assert_eq!(res.status, <span class="num">200</span>);
    assert!(res.is_success());

    <span class="comment">// Extract token from response</span>
    <span class="kw">let</span> token = res.data()[<span class="str">"token"</span>].as_str().unwrap();

    <span class="comment">// Login</span>
    <span class="kw">let</span> res = client.post_json(
        <span class="str">"/api/auth/login"</span>,
        <span class="str">r#"{"email":"test@example.com","password":"password123"}"#</span>,
    ).<span class="kw">await</span>;

    assert_eq!(res.status, <span class="num">200</span>);
    assert!(res.is_success());
}</code></pre>

                <h3>Authenticated requests</h3>
<pre><code><span class="attr">#[tokio::test]</span>
<span class="kw">async fn</span> <span class="fn">test_protected_endpoint</span>() {
    <span class="kw">let</span> test_app = TestApp::new().<span class="kw">await</span>;
    <span class="kw">let</span> client = test_app.client();

    <span class="comment">// Sign up to get a token</span>
    <span class="kw">let</span> res = client.post_json(<span class="str">"/api/auth/signup"</span>, <span class="str">r#"{"email":"a@b.com","password":"pass1234","name":"A"}"#</span>).<span class="kw">await</span>;
    <span class="kw">let</span> token = res.data()[<span class="str">"token"</span>].as_str().unwrap().to_string();

    <span class="comment">// Make authenticated requests</span>
    <span class="kw">let</span> res = client.get_with_auth(<span class="str">"/api/profile"</span>, &token).<span class="kw">await</span>;
    assert_eq!(res.status, <span class="num">200</span>);

    <span class="comment">// POST with auth</span>
    <span class="kw">let</span> res = client.post_with_auth(
        <span class="str">"/api/posts"</span>, &token,
        <span class="str">r#"{"title":"Test","body":"Content"}"#</span>,
    ).<span class="kw">await</span>;
    assert_eq!(res.status, <span class="num">201</span>);
}</code></pre>

                <h3>TestResponse helpers</h3>
<pre><code><span class="kw">let</span> res = client.get(<span class="str">"/"</span>).<span class="kw">await</span>;

res.status         <span class="comment">// u16 ‚Äî HTTP status code</span>
res.body           <span class="comment">// String ‚Äî raw response body</span>
res.json()         <span class="comment">// serde_json::Value</span>
res.is_success()   <span class="comment">// checks json["success"] == true</span>
res.data()         <span class="comment">// json["data"]</span>
res.error()        <span class="comment">// json["error"]</span></code></pre>

<pre><code><span class="comment"># Run all tests</span>
cargo test --all

<span class="comment"># Run specific test</span>
cargo test test_signup_and_login -- --nocapture</code></pre>
            </section>

            <!-- 18. Performance -->
            <section id="performance" class="tutorial-section">
                <div class="section-number">18</div>
                <h2>Performance</h2>
                <p>Chopin uses a unified <strong>ChopinService</strong> dispatcher for all requests. FastRoute endpoints bypass Axum with zero allocation, and all other routes go through the full middleware stack. Enable <strong>SO_REUSEPORT</strong> for multi-core parallelism.</p>

                <div class="mode-comparison">
                    <div class="mode-card">
                        <h4><i data-lucide="shield" class="inline-icon"></i> Default</h4>
                        <ul>
                            <li>Single listener, multi-thread tokio</li>
                            <li>FastRoute zero-alloc fast path</li>
                            <li>Full Axum middleware for other routes</li>
                            <li>~150K-300K req/s</li>
                        </ul>
                        <code>cargo run --release</code>
                    </div>
                    <div class="mode-card">
                        <h4><i data-lucide="zap" class="inline-icon"></i> REUSEPORT=true</h4>
                        <ul>
                            <li>Per-core current_thread tokio runtimes</li>
                            <li>SO_REUSEPORT kernel-level load balancing</li>
                            <li>Zero cross-thread synchronization</li>
                            <li>~500K-1.7M+ req/s</li>
                        </ul>
                        <code>REUSEPORT=true cargo run --release</code>
                    </div>
                </div>

                <h3>Fast routes &mdash; zero-allocation endpoints</h3>
                <p>FastRoute bypasses Axum middleware for maximum performance. Each route can be individually configured with <strong>decorators</strong> ‚Äî all pre-computed at registration time with zero per-request overhead.</p>

<h4>Basic usage</h4>
<pre><code><span class="kw">use</span> chopin_core::{App, FastRoute};

<span class="kw">let</span> app = App::new().<span class="kw">await</span>?
    <span class="comment">// Bare: maximum performance, no middleware (benchmark endpoints)</span>
    .fast_route(FastRoute::json(<span class="str">"/json"</span>, <span class="kw">br#</span><span class="str">{"message":"Hello, World!"}</span><span class="kw">#</span>))
    .fast_route(FastRoute::text(<span class="str">"/plaintext"</span>, <span class="kw">b</span><span class="str">"Hello, World!"</span>));

app.run().<span class="kw">await</span>?;</code></pre>

<h4>With CORS (frontend-accessible endpoints)</h4>
<pre><code><span class="kw">use</span> chopin_core::{App, FastRoute};

<span class="kw">let</span> app = App::new().<span class="kw">await</span>?
    <span class="comment">// Status endpoint with CORS + automatic OPTIONS preflight</span>
    .fast_route(
        FastRoute::json(<span class="str">"/api/status"</span>, <span class="kw">br#</span><span class="str">{"status":"ok"}</span><span class="kw">#</span>)
            .cors()                              <span class="comment">// adds Access-Control-Allow-Origin: *</span>
            .get_only()                          <span class="comment">// only GET/HEAD; POST falls through to Axum</span>
            .cache_control(<span class="str">"public, max-age=5"</span>)  <span class="comment">// static Cache-Control header</span>
    );

app.run().<span class="kw">await</span>?;</code></pre>

<h4>With custom headers</h4>
<pre><code><span class="kw">use</span> chopin_core::{App, FastRoute};
<span class="kw">use</span> chopin_core::http::header;

<span class="kw">let</span> app = App::new().<span class="kw">await</span>?
    <span class="comment">// Health endpoint with security headers</span>
    .fast_route(
        FastRoute::text(<span class="str">"/health"</span>, <span class="kw">b</span><span class="str">"OK"</span>)
            .header(header::X_CONTENT_TYPE_OPTIONS, <span class="str">"nosniff"</span>)
            .header(header::X_FRAME_OPTIONS, <span class="str">"DENY"</span>)
            .cache_control(<span class="str">"no-cache"</span>)
    );

app.run().<span class="kw">await</span>?;</code></pre>

<h4>Per-route trade-offs</h4>
<table>
    <thead>
        <tr>
            <th>Feature</th>
            <th>FastRoute (bare)</th>
            <th>FastRoute (+decorators)</th>
            <th>Axum Router</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><strong>Performance</strong></td>
            <td>~35ns</td>
            <td>~35ns</td>
            <td>~1,000-5,000ns</td>
        </tr>
        <tr>
            <td><strong>Throughput</strong></td>
            <td>~28M req/s</td>
            <td>~28M req/s</td>
            <td>~200K-1M req/s</td>
        </tr>
        <tr>
            <td>CORS</td>
            <td>‚Äî</td>
            <td><code>.cors()</code></td>
            <td>CorsLayer</td>
        </tr>
        <tr>
            <td>Cache-Control</td>
            <td>‚Äî</td>
            <td><code>.cache_control()</code></td>
            <td>manual</td>
        </tr>
        <tr>
            <td>Method filter</td>
            <td>‚Äî</td>
            <td><code>.get_only()</code> / <code>.methods()</code></td>
            <td>built-in</td>
        </tr>
        <tr>
            <td>Auth</td>
            <td>‚Äî</td>
            <td>‚Äî</td>
            <td>middleware</td>
        </tr>
        <tr>
            <td>Logging</td>
            <td>‚Äî</td>
            <td>‚Äî</td>
            <td>TraceLayer</td>
        </tr>
    </tbody>
</table>

<div class="tip">
    <strong>When to use FastRoute:</strong>
    <ul>
        <li><strong>Health checks</strong> ‚Äî <code>/health</code>, <code>/ready</code>, <code>/metrics</code></li>
        <li><strong>Static API responses</strong> ‚Äî <code>/api/status</code>, <code>/api/version</code></li>
        <li><strong>Benchmark endpoints</strong> ‚Äî <code>/json</code>, <code>/plaintext</code></li>
    </ul>
    <strong>When to use Axum Router:</strong>
    <ul>
        <li>Dynamic content (database queries, user input)</li>
        <li>Authentication required</li>
        <li>Request logging/tracing</li>
    </ul>
</div>

                <h3>How it works</h3>
                <div class="arch-flow">
<pre><code><span class="comment">ChopinService::call(req)  ‚Üê all requests go through this
  1. CORS preflight? (OPTIONS + .cors() enabled)
     ‚Üí pre-baked 204 No Content with CORS headers
  2. FastRoute path match + method allowed?
     ‚Üí pre-baked response (ZERO heap alloc, ~35ns)
  3. Axum Router
     ‚Üí full middleware stack (CORS, auth, tracing, etc.)

Request examples:
  GET /json            ‚Üí FastRoute (bare, ~35ns)
  GET /api/status      ‚Üí FastRoute (+cors, ~35ns)
  OPTIONS /api/status  ‚Üí FastRoute (204 preflight, automatic)
  POST /api/status     ‚Üí Axum (method not allowed on FastRoute)
  GET /users           ‚Üí Axum (dynamic content)

With REUSEPORT=true:
  SO_REUSEPORT x N CPU cores (kernel-level load balancing)
    ‚Üí per-core accept loop (current_thread runtime)
      ‚Üí TCP_NODELAY
        ‚Üí hyper HTTP/1.1 (keep-alive, pipeline_flush)
          ‚Üí ChopinService</span></code></pre>
                </div>

                <h3>Performance optimizations</h3>
                <div class="perf-grid">
                    <div class="perf-item">
                        <strong>mimalloc</strong>
                        <p>Global allocator replacing system malloc. Faster for multi-threaded workloads.</p>
                    </div>
                    <div class="perf-item">
                        <strong>sonic-rs</strong>
                        <p>SIMD-accelerated JSON. 2-3x faster than serde_json for parsing and serialization.</p>
                    </div>
                    <div class="perf-item">
                        <strong>Date header cache</strong>
                        <p>Lock-free AtomicU64 + thread-local cache. Updated every 500ms. ~8ns per request vs ~100ns.</p>
                    </div>
                    <div class="perf-item">
                        <strong>SO_REUSEPORT</strong>
                        <p>Kernel distributes TCP connections across cores. Eliminates accept() contention.</p>
                    </div>
                </div>

                <h3>Cargo.toml profile for benchmarks</h3>
<pre><code><span class="comment"># Cargo.toml ‚Äî add this for maximum throughput</span>
[profile.release]
lto = "fat"
codegen-units = 1
opt-level = 3
strip = true

[profile.release.build-override]
opt-level = 3</code></pre>

                <h3>Benchmark with wrk</h3>
<pre><code><span class="comment"># Start server with SO_REUSEPORT</span>
REUSEPORT=true cargo run --release

<span class="comment"># Benchmark (in another terminal)</span>
wrk -t4 -c256 -d10s http://127.0.0.1:3000/json
wrk -t4 -c256 -d10s http://127.0.0.1:3000/plaintext</code></pre>
            </section>

            <!-- 19. Production Deployment -->
            <section id="production" class="tutorial-section">
                <div class="section-number">19</div>
                <h2>Production Deployment</h2>
                <p>Ship your Chopin API to production with a compiled Rust binary. No runtime, no garbage collector, no cold starts.</p>

                <h3>Build for production</h3>
<pre><code><span class="comment"># Optimized release build</span>
cargo build --release

<span class="comment"># With performance features</span>
cargo build --release --features perf

<span class="comment"># Result: a single static binary</span>
ls -lh target/release/my-api
<span class="comment"># -rwxr-xr-x  1 user  staff  12M  my-api</span></code></pre>

                <h3>Production .env</h3>
<pre><code><span class="comment"># Production environment</span>
ENVIRONMENT=production
REUSEPORT=true                  <span class="comment"># enable multi-core SO_REUSEPORT</span>
SERVER_HOST=0.0.0.0
SERVER_PORT=3000

<span class="comment"># Production database</span>
DATABASE_URL=postgres://user:pass@db.example.com/myapp

<span class="comment"># Strong JWT secret (generate with: openssl rand -hex 64)</span>
JWT_SECRET=your-very-long-random-secret-here
JWT_EXPIRY_HOURS=24

<span class="comment"># Redis for caching</span>
REDIS_URL=redis://redis.example.com:6379

<span class="comment"># S3 for file uploads</span>
S3_BUCKET=prod-uploads
S3_REGION=us-east-1
S3_ACCESS_KEY=AKIA...
S3_SECRET_KEY=...
S3_PUBLIC_URL=https://cdn.example.com</code></pre>

                <h3>Docker</h3>
<pre><code><span class="comment"># Dockerfile</span>
FROM rust:1.82-slim AS builder
WORKDIR /app
COPY . .
RUN cargo build --release --features perf

FROM debian:bookworm-slim
RUN apt-get update && apt-get install -y ca-certificates && rm -rf /var/lib/apt/lists/*
COPY --from=builder /app/target/release/my-api /usr/local/bin/
EXPOSE 3000
CMD ["my-api"]</code></pre>

<pre><code><span class="comment"># Build and run</span>
docker build -t my-api .
docker run -p 3000:3000 --env-file .env my-api</code></pre>

                <h3>Systemd service</h3>
<pre><code><span class="comment"># /etc/systemd/system/my-api.service</span>
[Unit]
Description=My Chopin API
After=network.target postgresql.service

[Service]
Type=simple
User=www-data
WorkingDirectory=/opt/my-api
EnvironmentFile=/opt/my-api/.env
ExecStart=/opt/my-api/my-api
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target</code></pre>

<pre><code><span class="comment"># Deploy</span>
sudo systemctl daemon-reload
sudo systemctl enable my-api
sudo systemctl start my-api
sudo systemctl status my-api</code></pre>

                <h3>Production checklist</h3>
                <div class="checklist">
                    <label><input type="checkbox"> Change <code>JWT_SECRET</code> to a strong random value</label>
                    <label><input type="checkbox"> Set <code>ENVIRONMENT=production</code></label>
                    <label><input type="checkbox"> Use PostgreSQL or MySQL instead of SQLite</label>
                    <label><input type="checkbox"> Set up Redis for caching</label>
                    <label><input type="checkbox"> Configure S3/R2 for file uploads</label>
                    <label><input type="checkbox"> Build with <code>--release --features perf</code></label>
                    <label><input type="checkbox"> Set up HTTPS via reverse proxy (nginx/Caddy)</label>
                    <label><input type="checkbox"> Verify all security features are enabled (default)</label>
                    <label><input type="checkbox"> Set <code>SECURITY_MIN_PASSWORD_LENGTH=12</code> or higher</label>
                    <label><input type="checkbox"> Integrate email sending for password reset &amp; verification tokens</label>
                    <label><input type="checkbox"> Configure logging and monitoring</label>
                    <label><input type="checkbox"> Set up database backups</label>
                    <label><input type="checkbox"> Run <code>cargo test --all</code> before deploying</label>
                </div>
            </section>

            <!-- Final CTA -->
            <section class="tutorial-cta">
                <h2>Start Building</h2>
                <p>You now know everything Chopin has to offer. From a 4-line hello world to a production-deployed API with auth, caching, file uploads, and 657K+ req/s performance.</p>
                <div class="cta-actions">
                    <a href="https://github.com/kowito/chopin" class="btn-primary">View on GitHub</a>
                    <a href="https://github.com/kowito/chopin/tree/main/chopin-examples" class="btn-secondary">Browse Examples</a>
                    <a href="https://docs.rs/chopin" class="btn-secondary">API Reference</a>
                </div>
            </section>

        </main>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-bottom" style="border-top: none; padding-top: 0;">
                <div class="footer-bottom-left">
                    <p>&copy; 2026 Chopin. All rights reserved.</p>
                </div>
                <div class="footer-bottom-right">
                    <p>Made with <i data-lucide="music" class="inline-icon-sm"></i> by the <a href="https://github.com/kowito">Chopin team</a></p>
                </div>
            </div>
        </div>
    </footer>

    <script src="js/main.js"></script>
    <script>
        lucide.createIcons();

        // Active TOC highlighting on scroll
        const sections = document.querySelectorAll('.tutorial-section');
        const tocLinks = document.querySelectorAll('.toc-link');

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    tocLinks.forEach(link => link.classList.remove('active'));
                    const id = entry.target.getAttribute('id');
                    const activeLink = document.querySelector(`.toc-link[href="#${id}"]`);
                    if (activeLink) activeLink.classList.add('active');
                }
            });
        }, { rootMargin: '-80px 0px -60% 0px' });

        sections.forEach(section => observer.observe(section));
    </script>
</body>
</html>
